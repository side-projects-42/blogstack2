{"expireTime":9007200914465211000,"key":"transformer-remark-markdown-html-ast-cb6a4719ce9e829b01df82d33139d8ed--","val":{"type":"root","children":[{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\n\nAbstract\n\n   The Hypertext Transfer Protocol (HTTP) is a stateless application-\n   level protocol for distributed, collaborative, hypertext information\n   systems.  This document defines the semantics of HTTP/1.1 messages,\n   as expressed by request methods, request header fields, response\n   status codes, and response header fields, along with the payload of\n   messages (metadata and body content) and mechanisms for content\n   negotiation.\n\nStatus of This Memo\n\n   This is an Internet Standards Track document.\n\n   This document is a product of the Internet Engineering Task Force\n   (IETF).  It represents the consensus of the IETF community.  It has\n   received public review and has been approved for publication by the\n   Internet Engineering Steering Group (IESG).  Further information on\n   Internet Standards is available in SectionÂ 2 of RFC 5741.\n\n   Information about the current status of this document, any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7231.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                    [Page 1]\n"}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":46,"column":4,"offset":1192}}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":46,"column":4,"offset":1192}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":48,"column":1,"offset":1194},"end":{"line":48,"column":4,"offset":1197}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\nCopyright Notice\n\n   Copyright (c) 2014 IETF Trust and the persons identified as the\n   document authors.  All rights reserved.\n\n   This document is subject to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication of this document.  Please review these documents\n   carefully, as they describe your rights and restrictions with respect\n   to this document.  Code Components extracted from this document must\n   include Simplified BSD License text as described in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty as\n   described in the Simplified BSD License.\n\n   This document may contain material from IETF Documents or IETF\n   Contributions published or made publicly available before November\n   10, 2008.  The person(s) controlling the copyright in some of this\n   material may not have granted the IETF Trust the right to allow\n   modifications of such material outside the IETF Standards Process.\n   Without obtaining an adequate license from the person(s) controlling\n   the copyright in such materials, this document may not be modified\n   outside the IETF Standards Process, and derivative works of it may\n   not be created outside the IETF Standards Process, except to format\n   it for publication as an RFC or to translate it into languages other\n   than English.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                    [Page 2]\n"}],"position":{"start":{"line":50,"column":1,"offset":1199},"end":{"line":107,"column":4,"offset":2788}}}],"position":{"start":{"line":50,"column":1,"offset":1199},"end":{"line":107,"column":4,"offset":2788}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":109,"column":1,"offset":2790},"end":{"line":109,"column":4,"offset":2793}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\nTable of Contents\n\n   1. Introduction ....................................................6\n      1.1. Conformance and Error Handling .............................6\n      1.2. Syntax Notation ............................................6\n   2. Resources .......................................................7\n   3. Representations .................................................7\n      3.1. Representation Metadata ....................................8\n           3.1.1. Processing Representation Data ......................8\n           3.1.2. Encoding for Compression or Integrity ..............11\n           3.1.3. Audience Language ..................................13\n           3.1.4. Identification .....................................14\n      3.2. Representation Data .......................................17\n      3.3. Payload Semantics .........................................17\n      3.4. Content Negotiation .......................................18\n           3.4.1. Proactive Negotiation ..............................19\n           3.4.2. Reactive Negotiation ...............................20\n   4. Request Methods ................................................21\n      4.1. Overview ..................................................21\n      4.2. Common Method Properties ..................................22\n           4.2.1. Safe Methods .......................................22\n           4.2.2. Idempotent Methods .................................23\n           4.2.3. Cacheable Methods ..................................24\n      4.3. Method Definitions ........................................24\n           4.3.1. GET ................................................24\n           4.3.2. HEAD ...............................................25\n           4.3.3. POST ...............................................25\n           4.3.4. PUT ................................................26\n           4.3.5. DELETE .............................................29\n           4.3.6. CONNECT ............................................30\n           4.3.7. OPTIONS ............................................31\n           4.3.8. TRACE ..............................................32\n   5. Request Header Fields ..........................................33\n      5.1. Controls ..................................................33\n           5.1.1. Expect .............................................34\n           5.1.2. Max-Forwards .......................................36\n      5.2. Conditionals ..............................................36\n      5.3. Content Negotiation .......................................37\n           5.3.1. Quality Values .....................................37\n           5.3.2. Accept .............................................38\n           5.3.3. Accept-Charset .....................................40\n           5.3.4. Accept-Encoding ....................................41\n           5.3.5. Accept-Language ....................................42\n      5.4. Authentication Credentials ................................44\n      5.5. Request Context ...........................................44\n           5.5.1. From ...............................................44\n           5.5.2. Referer ............................................45\n           5.5.3. User-Agent .........................................46\n\n\n\nFielding & Reschke           Standards Track                    [Page 3]\n"}],"position":{"start":{"line":111,"column":1,"offset":2795},"end":{"line":168,"column":4,"offset":6331}}}],"position":{"start":{"line":111,"column":1,"offset":2795},"end":{"line":168,"column":4,"offset":6331}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":170,"column":1,"offset":6333},"end":{"line":170,"column":4,"offset":6336}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   6. Response Status Codes ..........................................47\n      6.1. Overview of Status Codes ..................................48\n      6.2. Informational 1xx .........................................50\n           6.2.1. 100 Continue .......................................50\n           6.2.2. 101 Switching Protocols ............................50\n      6.3. Successful 2xx ............................................51\n           6.3.1. 200 OK .............................................51\n           6.3.2. 201 Created ........................................52\n           6.3.3. 202 Accepted .......................................52\n           6.3.4. 203 Non-Authoritative Information ..................52\n           6.3.5. 204 No Content .....................................53\n           6.3.6. 205 Reset Content ..................................53\n      6.4. Redirection 3xx ...........................................54\n           6.4.1. 300 Multiple Choices ...............................55\n           6.4.2. 301 Moved Permanently ..............................56\n           6.4.3. 302 Found ..........................................56\n           6.4.4. 303 See Other ......................................57\n           6.4.5. 305 Use Proxy ......................................58\n           6.4.6. 306 (Unused) .......................................58\n           6.4.7. 307 Temporary Redirect .............................58\n      6.5. Client Error 4xx ..........................................58\n           6.5.1. 400 Bad Request ....................................58\n           6.5.2. 402 Payment Required ...............................59\n           6.5.3. 403 Forbidden ......................................59\n           6.5.4. 404 Not Found ......................................59\n           6.5.5. 405 Method Not Allowed .............................59\n           6.5.6. 406 Not Acceptable .................................60\n           6.5.7. 408 Request Timeout ................................60\n           6.5.8. 409 Conflict .......................................60\n           6.5.9. 410 Gone ...........................................60\n           6.5.10. 411 Length Required ...............................61\n           6.5.11. 413 Payload Too Large .............................61\n           6.5.12. 414 URI Too Long ..................................61\n           6.5.13. 415 Unsupported Media Type ........................62\n           6.5.14. 417 Expectation Failed ............................62\n           6.5.15. 426 Upgrade Required ..............................62\n      6.6. Server Error 5xx ..........................................62\n           6.6.1. 500 Internal Server Error ..........................63\n           6.6.2. 501 Not Implemented ................................63\n           6.6.3. 502 Bad Gateway ....................................63\n           6.6.4. 503 Service Unavailable ............................63\n           6.6.5. 504 Gateway Timeout ................................63\n           6.6.6. 505 HTTP Version Not Supported .....................64\n   7. Response Header Fields .........................................64\n      7.1. Control Data ..............................................64\ned            7.1.1. Origination Date ...................................65\n           7.1.2. Location ...........................................68\n           7.1.3. Retry-After ........................................69\n\n\n\nFielding & Reschke           Standards Track                    [Page 4]\n"}],"position":{"start":{"line":172,"column":1,"offset":6338},"end":{"line":229,"column":4,"offset":10004}}}],"position":{"start":{"line":172,"column":1,"offset":6338},"end":{"line":229,"column":4,"offset":10004}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":231,"column":1,"offset":10006},"end":{"line":231,"column":4,"offset":10009}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n           7.1.4. Vary ...............................................70\n      7.2. Validator Header Fields ...................................71\n      7.3. Authentication Challenges .................................72\n      7.4. Response Context ..........................................72\n           7.4.1. Allow ..............................................72\n           7.4.2. Server .............................................73\n   8. IANA Considerations ............................................73\n      8.1. Method Registry ...........................................73\n           8.1.1. Procedure ..........................................74\n           8.1.2. Considerations for New Methods .....................74\n           8.1.3. Registrations ......................................75\n      8.2. Status Code Registry ......................................75\n           8.2.1. Procedure ..........................................75\n           8.2.2. Considerations for New Status Codes ................76\n           8.2.3. Registrations ......................................76\n      8.3. Header Field Registry .....................................77\n           8.3.1. Considerations for New Header Fields ...............78\n           8.3.2. Registrations ......................................80\n      8.4. Content Coding Registry ...................................81\n           8.4.1. Procedure ..........................................81\n           8.4.2. Registrations ......................................81\n   9. Security Considerations ........................................81\n      9.1. Attacks Based on File and Path Names ......................82\n      9.2. Attacks Based on Command, Code, or Query Injection ........82\n      9.3. Disclosure of Personal Information ........................83\n      9.4. Disclosure of Sensitive Information in URIs ...............83\n      9.5. Disclosure of Fragment after Redirects ....................84\n      9.6. Disclosure of Product Information .........................84\n      9.7. Browser Fingerprinting ....................................84\n   10. Acknowledgments ...............................................85\n   11. References ....................................................85\n      11.1. Normative References .....................................85\n      11.2. Informative References ...................................86\n   Appendix A. Differences between HTTP and MIME .....................89\n      A.1. MIME-Version ..............................................89\n      A.2. Conversion to Canonical Form ..............................89\n      A.3. Conversion of Date Formats ................................90\n      A.4. Conversion of Content-Encoding ............................90\n      A.5. Conversion of Content-Transfer-Encoding ...................90\n      A.6. MHTML and Line Length Limitations .........................90\n   Appendix B. Changes from RFC 2616 .................................91\n   Appendix C. Imported ABNF .........................................93\n   Appendix D. Collected ABNF ........................................94\n   Index .............................................................97\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                    [Page 5]\n"}],"position":{"start":{"line":233,"column":1,"offset":10011},"end":{"line":290,"column":4,"offset":13386}}}],"position":{"start":{"line":233,"column":1,"offset":10011},"end":{"line":290,"column":4,"offset":13386}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":292,"column":1,"offset":13388},"end":{"line":292,"column":4,"offset":13391}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n1.  Introduction\n\n   Each Hypertext Transfer Protocol (HTTP) message is either a request\n   or a response.  A server listens on a connection for a request,\n   parses each message received, interprets the message semantics in\n   relation to the identified request target, and responds to that\n   request with one or more response messages.  A client constructs\n   request messages to communicate specific intentions, examines\n   received responses to see if the intentions were carried out, and\n   determines how to interpret the results.  This document defines\n   HTTP/1.1 request and response semantics in terms of the architecture\n   defined in [RFC7230].\n\n   HTTP provides a uniform interface for interacting with a resource\n   (Section 2), regardless of its type, nature, or implementation, via\n   the manipulation and transfer of representations (Section 3).\n\n   HTTP semantics include the intentions defined by each request method\n   (Section 4), extensions to those semantics that might be described in\n   request header fields (Section 5), the meaning of status codes to\n   indicate a machine-readable response (Section 6), and the meaning of\n   other control data and resource metadata that might be given in\n   response header fields (Section 7).\n\n   This document also defines representation metadata that describe how\n   a payload is intended to be interpreted by a recipient, the request\n   header fields that might influence content selection, and the various\n   selection algorithms that are collectively referred to as \"content\n   negotiation\" (Section 3.4).\n\n1.1.  Conformance and Error Handling\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\n   Conformance criteria and considerations regarding error handling are\n   defined in SectionÂ 2.5 of [RFC7230].\n\n1.2.  Syntax Notation\n\n   This specification uses the Augmented Backus-Naur Form (ABNF)\n   notation of [RFC5234] with a list extension, defined in SectionÂ 7 of\n   [RFC7230], that allows for compact definition of comma-separated\n   lists using a '#' operator (similar to how the '*' operator indicates\n   repetition).  Appendix C describes rules imported from other\n   documents.  Appendix D shows the collected grammar with all list\n   operators expanded to standard ABNF notation.\n\n\n\nFielding & Reschke           Standards Track                    [Page 6]\n"}],"position":{"start":{"line":294,"column":1,"offset":13393},"end":{"line":351,"column":4,"offset":15966}}}],"position":{"start":{"line":294,"column":1,"offset":13393},"end":{"line":351,"column":4,"offset":15966}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":353,"column":1,"offset":15968},"end":{"line":353,"column":4,"offset":15971}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   This specification uses the terms \"character\", \"character encoding\n   scheme\", \"charset\", and \"protocol element\" as they are defined in\n   [RFC6365].\n\n2.  Resources\n\n   The target of an HTTP request is called a \"resource\".  HTTP does not\n   limit the nature of a resource; it merely defines an interface that\n   might be used to interact with resources.  Each resource is\n   identified by a Uniform Resource Identifier (URI), as described in\n   SectionÂ 2.7 of [RFC7230].\n\n   When a client constructs an HTTP/1.1 request message, it sends the\n   target URI in one of various forms, as defined in (SectionÂ 5.3 of\n   [RFC7230]).  When a request is received, the server reconstructs an\n   effective request URI for the target resource (SectionÂ 5.5 of\n   [RFC7230]).\n\n   One design goal of HTTP is to separate resource identification from\n   request semantics, which is made possible by vesting the request\n   semantics in the request method (Section 4) and a few\n   request-modifying header fields (Section 5).  If there is a conflict\n   between the method semantics and any semantic implied by the URI\n   itself, as described in Section 4.2.1, the method semantics take\n   precedence.\n\n3.  Representations\n\n   Considering that a resource could be anything, and that the uniform\n   interface provided by HTTP is similar to a window through which one\n   can observe and act upon such a thing only through the communication\n   of messages to some independent actor on the other side, an\n   abstraction is needed to represent (\"take the place of\") the current\n   or desired state of that thing in our communications.  That\n   abstraction is called a representation [REST].\n\n   For the purposes of HTTP, a \"representation\" is information that is\n   intended to reflect a past, current, or desired state of a given\n   resource, in a format that can be readily communicated via the\n   protocol, and that consists of a set of representation metadata and a\n   potentially unbounded stream of representation data.\n\n   An origin server might be provided with, or be capable of generating,\n   multiple representations that are each intended to reflect the\n   current state of a target resource.  In such cases, some algorithm is\n   used by the origin server to select one of those representations as\n   most applicable to a given request, usually based on content\n   negotiation.  This \"selected representation\" is used to provide the\n\n\n\nFielding & Reschke           Standards Track                    [Page 7]\n"}],"position":{"start":{"line":355,"column":1,"offset":15973},"end":{"line":412,"column":4,"offset":18555}}}],"position":{"start":{"line":355,"column":1,"offset":15973},"end":{"line":412,"column":4,"offset":18555}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":414,"column":1,"offset":18557},"end":{"line":414,"column":4,"offset":18560}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   data and metadata for evaluating conditional requests [RFC7232] and\n   constructing the payload for 200 (OK) and 304 (Not Modified)\n   responses to GET (Section 4.3.1).\n\n3.1.  Representation Metadata\n\n   Representation header fields provide metadata about the\n   representation.  When a message includes a payload body, the\n   representation header fields describe how to interpret the\n   representation data enclosed in the payload body.  In a response to a\n   HEAD request, the representation header fields describe the\n   representation data that would have been enclosed in the payload body\n   if the same request had been a GET.\n\n   The following header fields convey representation metadata:\n\n   +-------------------+-----------------+\n   | Header Field Name | Defined in...   |\n   +-------------------+-----------------+\n   | Content-Type      | Section 3.1.1.5 |\n   | Content-Encoding  | Section 3.1.2.2 |\n   | Content-Language  | Section 3.1.3.2 |\n   | Content-Location  | Section 3.1.4.2 |\n   +-------------------+-----------------+\n\n3.1.1.  Processing Representation Data\n\n3.1.1.1.  Media Type\n\n   HTTP uses Internet media types [RFC2046] in the Content-Type\n   (Section 3.1.1.5) and Accept (Section 5.3.2) header fields in order\n   to provide open and extensible data typing and type negotiation.\n   Media types define both a data format and various processing models:\n   how to process that data in accordance with each context in which it\n   is received.\n\n     media-type = type \"/\" subtype *( OWS \";\" OWS parameter )\n     type       = token\n     subtype    = token\n\n   The type/subtype MAY be followed by parameters in the form of\n   name=value pairs.\n\n     parameter      = token \"=\" ( token / quoted-string )\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                    [Page 8]\n"}],"position":{"start":{"line":416,"column":1,"offset":18562},"end":{"line":473,"column":4,"offset":20454}}}],"position":{"start":{"line":416,"column":1,"offset":18562},"end":{"line":473,"column":4,"offset":20454}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":475,"column":1,"offset":20456},"end":{"line":475,"column":4,"offset":20459}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   The type, subtype, and parameter name tokens are case-insensitive.\n   Parameter values might or might not be case-sensitive, depending on\n   the semantics of the parameter name.  The presence or absence of a\n   parameter might be significant to the processing of a media-type,\n   depending on its definition within the media type registry.\n\n   A parameter value that matches the token production can be\n   transmitted either as a token or within a quoted-string.  The quoted\n   and unquoted values are equivalent.  For example, the following\n   examples are all equivalent, but the first is preferred for\n   consistency:\n\n     text/html;charset=utf-8\n     text/html;charset=UTF-8\n     Text/HTML;Charset=\"utf-8\"\n     text/html; charset=\"utf-8\"\n\n   Internet media types ought to be registered with IANA according to\n   the procedures defined in [BCP13].\n\n      Note: Unlike some similar constructs in other header fields, media\n      type parameters do not allow whitespace (even \"bad\" whitespace)\n      around the \"=\" character.\n\n3.1.1.2.  Charset\n\n   HTTP uses charset names to indicate or negotiate the character\n   encoding scheme of a textual representation [RFC6365].  A charset is\n   identified by a case-insensitive token.\n\n     charset = token\n\n   Charset names ought to be registered in the IANA \"Character Sets\"\n   registry (<http://www.iana.org/assignments/character-sets>) according\n   to the procedures defined in [RFC2978].\n\n3.1.1.3.  Canonicalization and Text Defaults\n\n   Internet media types are registered with a canonical form in order to\n   be interoperable among systems with varying native encoding formats.\n   Representations selected or transferred via HTTP ought to be in\n   canonical form, for many of the same reasons described by the\n   Multipurpose Internet Mail Extensions (MIME) [RFC2045].  However, the\n   performance characteristics of email deployments (i.e., store and\n   forward messages to peers) are significantly different from those\n   common to HTTP and the Web (server-based information services).\n   Furthermore, MIME's constraints for the sake of compatibility with\n   older mail transfer protocols do not apply to HTTP (see Appendix A).\n\n\n\nFielding & Reschke           Standards Track                    [Page 9]\n"}],"position":{"start":{"line":477,"column":1,"offset":20461},"end":{"line":534,"column":4,"offset":22804}}}],"position":{"start":{"line":477,"column":1,"offset":20461},"end":{"line":534,"column":4,"offset":22804}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":536,"column":1,"offset":22806},"end":{"line":536,"column":4,"offset":22809}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   MIME's canonical form requires that media subtypes of the \"text\" type\n   use CRLF as the text line break.  HTTP allows the transfer of text\n   media with plain CR or LF alone representing a line break, when such\n   line breaks are consistent for an entire representation.  An HTTP\n   sender MAY generate, and a recipient MUST be able to parse, line\n   breaks in text media that consist of CRLF, bare CR, or bare LF.  In\n   addition, text media in HTTP is not limited to charsets that use\n   octets 13 and 10 for CR and LF, respectively.  This flexibility\n   regarding line breaks applies only to text within a representation\n   that has been assigned a \"text\" media type; it does not apply to\n   \"multipart\" types or HTTP elements outside the payload body (e.g.,\n   header fields).\n\n   If a representation is encoded with a content-coding, the underlying\n   data ought to be in a form defined above prior to being encoded.\n\n3.1.1.4.  Multipart Types\n\n   MIME provides for a number of \"multipart\" types -- encapsulations of\n   one or more representations within a single message body.  All\n   multipart types share a common syntax, as defined in SectionÂ 5.1.1 of\n   [RFC2046], and include a boundary parameter as part of the media type\n   value.  The message body is itself a protocol element; a sender MUST\n   generate only CRLF to represent line breaks between body parts.\n\n   HTTP message framing does not use the multipart boundary as an\n   indicator of message body length, though it might be used by\n   implementations that generate or process the payload.  For example,\n   the \"multipart/form-data\" type is often used for carrying form data\n   in a request, as described in [RFC2388], and the \"multipart/\n   byteranges\" type is defined by this specification for use in some 206\n   (Partial Content) responses [RFC7233].\n\n3.1.1.5.  Content-Type\n\n   The \"Content-Type\" header field indicates the media type of the\n   associated representation: either the representation enclosed in the\n   message payload or the selected representation, as determined by the\n   message semantics.  The indicated media type defines both the data\n   format and how that data is intended to be processed by a recipient,\n   within the scope of the received message semantics, after any content\n   codings indicated by Content-Encoding are decoded.\n\n     Content-Type = media-type\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 10]\n"}],"position":{"start":{"line":538,"column":1,"offset":22811},"end":{"line":595,"column":4,"offset":25340}}}],"position":{"start":{"line":538,"column":1,"offset":22811},"end":{"line":595,"column":4,"offset":25340}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":597,"column":1,"offset":25342},"end":{"line":597,"column":4,"offset":25345}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Media types are defined in Section 3.1.1.1.  An example of the field\n   is\n\n     Content-Type: text/html; charset=ISO-8859-4\n\n   A sender that generates a message containing a payload body SHOULD\n   generate a Content-Type header field in that message unless the\n   intended media type of the enclosed representation is unknown to the\n   sender.  If a Content-Type header field is not present, the recipient\n   MAY either assume a media type of \"application/octet-stream\"\n   ([RFC2046], SectionÂ 4.5.1) or examine the data to determine its type.\n\n   In practice, resource owners do not always properly configure their\n   origin server to provide the correct Content-Type for a given\n   representation, with the result that some clients will examine a\n   payload's content and override the specified type.  Clients that do\n   so risk drawing incorrect conclusions, which might expose additional\n   security risks (e.g., \"privilege escalation\").  Furthermore, it is\n   impossible to determine the sender's intent by examining the data\n   format: many data formats match multiple media types that differ only\n   in processing semantics.  Implementers are encouraged to provide a\n   means of disabling such \"content sniffing\" when it is used.\n\n3.1.2.  Encoding for Compression or Integrity\n\n3.1.2.1.  Content Codings\n\n   Content coding values indicate an encoding transformation that has\n   been or can be applied to a representation.  Content codings are\n   primarily used to allow a representation to be compressed or\n   otherwise usefully transformed without losing the identity of its\n   underlying media type and without loss of information.  Frequently,\n   the representation is stored in coded form, transmitted directly, and\n   only decoded by the final recipient.\n\n     content-coding   = token\n\n   All content-coding values are case-insensitive and ought to be\n   registered within the \"HTTP Content Coding Registry\", as defined in\n   Section 8.4.  They are used in the Accept-Encoding (Section 5.3.4)\n   and Content-Encoding (Section 3.1.2.2) header fields.\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 11]\n"}],"position":{"start":{"line":599,"column":1,"offset":25347},"end":{"line":656,"column":4,"offset":27580}}}],"position":{"start":{"line":599,"column":1,"offset":25347},"end":{"line":656,"column":4,"offset":27580}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":658,"column":1,"offset":27582},"end":{"line":658,"column":4,"offset":27585}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   The following content-coding values are defined by this\n   specification:\n\n      compress (and x-compress): See SectionÂ 4.2.1 of [RFC7230].\n\n      deflate: See SectionÂ 4.2.2 of [RFC7230].\n\n      gzip (and x-gzip): See SectionÂ 4.2.3 of [RFC7230].\n\n3.1.2.2.  Content-Encoding\n\n   The \"Content-Encoding\" header field indicates what content codings\n   have been applied to the representation, beyond those inherent in the\n   media type, and thus what decoding mechanisms have to be applied in\n   order to obtain data in the media type referenced by the Content-Type\n   header field.  Content-Encoding is primarily used to allow a\n   representation's data to be compressed without losing the identity of\n   its underlying media type.\n\n     Content-Encoding = 1#content-coding\n\n   An example of its use is\n\n     Content-Encoding: gzip\n\n   If one or more encodings have been applied to a representation, the\n   sender that applied the encodings MUST generate a Content-Encoding\n   header field that lists the content codings in the order in which\n   they were applied.  Additional information about the encoding\n   parameters can be provided by other header fields not defined by this\n   specification.\n\n   Unlike Transfer-Encoding (SectionÂ 3.3.1 of [RFC7230]), the codings\n   listed in Content-Encoding are a characteristic of the\n   representation; the representation is defined in terms of the coded\n   form, and all other metadata about the representation is about the\n   coded form unless otherwise noted in the metadata definition.\n   Typically, the representation is only decoded just prior to rendering\n   or analogous usage.\n\n   If the media type includes an inherent encoding, such as a data\n   format that is always compressed, then that encoding would not be\n   restated in Content-Encoding even if it happens to be the same\n   algorithm as one of the content codings.  Such a content coding would\n   only be listed if, for some bizarre reason, it is applied a second\n   time to form the representation.  Likewise, an origin server might\n   choose to publish the same data as multiple representations that\n   differ only in whether the coding is defined as part of Content-Type\n\n\n\nFielding & Reschke           Standards Track                   [Page 12]\n"}],"position":{"start":{"line":660,"column":1,"offset":27587},"end":{"line":717,"column":4,"offset":29932}}}],"position":{"start":{"line":660,"column":1,"offset":27587},"end":{"line":717,"column":4,"offset":29932}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":719,"column":1,"offset":29934},"end":{"line":719,"column":4,"offset":29937}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   or Content-Encoding, since some user agents will behave differently\n   in their handling of each response (e.g., open a \"Save as ...\" dialog\n   instead of automatic decompression and rendering of content).\n\n   An origin server MAY respond with a status code of 415 (Unsupported\n   Media Type) if a representation in the request message has a content\n   coding that is not acceptable.\n\n3.1.3.  Audience Language\n\n3.1.3.1.  Language Tags\n\n   A language tag, as defined in [RFC5646], identifies a natural\n   language spoken, written, or otherwise conveyed by human beings for\n   communication of information to other human beings.  Computer\n   languages are explicitly excluded.\n\n   HTTP uses language tags within the Accept-Language and\n   Content-Language header fields.  Accept-Language uses the broader\n   language-range production defined in Section 5.3.5, whereas\n   Content-Language uses the language-tag production defined below.\n\n     language-tag = <Language-Tag, see [RFC5646], SectionÂ 2.1>\n\n   A language tag is a sequence of one or more case-insensitive subtags,\n   each separated by a hyphen character (\"-\", %x2D).  In most cases, a\n   language tag consists of a primary language subtag that identifies a\n   broad family of related languages (e.g., \"en\" = English), which is\n   optionally followed by a series of subtags that refine or narrow that\n   language's range (e.g., \"en-CA\" = the variety of English as\n   communicated in Canada).  Whitespace is not allowed within a language\n   tag.  Example tags include:\n\n     fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN\n\n   See [RFC5646] for further information.\n\n3.1.3.2.  Content-Language\n\n   The \"Content-Language\" header field describes the natural language(s)\n   of the intended audience for the representation.  Note that this\n   might not be equivalent to all the languages used within the\n   representation.\n\n     Content-Language = 1#language-tag\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 13]\n"}],"position":{"start":{"line":721,"column":1,"offset":29939},"end":{"line":778,"column":4,"offset":32025}}}],"position":{"start":{"line":721,"column":1,"offset":29939},"end":{"line":778,"column":4,"offset":32025}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":780,"column":1,"offset":32027},"end":{"line":780,"column":4,"offset":32030}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Language tags are defined in Section 3.1.3.1.  The primary purpose of\n   Content-Language is to allow a user to identify and differentiate\n   representations according to the users' own preferred language.\n   Thus, if the content is intended only for a Danish-literate audience,\n   the appropriate field is\n\n     Content-Language: da\n\n   If no Content-Language is specified, the default is that the content\n   is intended for all language audiences.  This might mean that the\n   sender does not consider it to be specific to any natural language,\n   or that the sender does not know for which language it is intended.\n\n   Multiple languages MAY be listed for content that is intended for\n   multiple audiences.  For example, a rendition of the \"Treaty of\n   Waitangi\", presented simultaneously in the original Maori and English\n   versions, would call for\n\n     Content-Language: mi, en\n\n   However, just because multiple languages are present within a\n   representation does not mean that it is intended for multiple\n   linguistic audiences.  An example would be a beginner's language\n   primer, such as \"A First Lesson in Latin\", which is clearly intended\n   to be used by an English-literate audience.  In this case, the\n   Content-Language would properly only include \"en\".\n\n   Content-Language MAY be applied to any media type -- it is not\n   limited to textual documents.\n\n3.1.4.  Identification\n\n3.1.4.1.  Identifying a Representation\n\n   When a complete or partial representation is transferred in a message\n   payload, it is often desirable for the sender to supply, or the\n   recipient to determine, an identifier for a resource corresponding to\n   that representation.\n\n   For a request message:\n\n   o  If the request has a Content-Location header field, then the\n      sender asserts that the payload is a representation of the\n      resource identified by the Content-Location field-value.  However,\n      such an assertion cannot be trusted unless it can be verified by\n      other means (not defined by this specification).  The information\n      might still be useful for revision history links.\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 14]\n"}],"position":{"start":{"line":782,"column":1,"offset":32032},"end":{"line":839,"column":4,"offset":34307}}}],"position":{"start":{"line":782,"column":1,"offset":32032},"end":{"line":839,"column":4,"offset":34307}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":841,"column":1,"offset":34309},"end":{"line":841,"column":4,"offset":34312}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   o  Otherwise, the payload is unidentified.\n\n   For a response message, the following rules are applied in order\n   until a match is found:\n\n   1.  If the request method is GET or HEAD and the response status code\n       is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not\n       Modified), the payload is a representation of the resource\n       identified by the effective request URI (SectionÂ 5.5 of\n       [RFC7230]).\n\n   2.  If the request method is GET or HEAD and the response status code\n       is 203 (Non-Authoritative Information), the payload is a\n       potentially modified or enhanced representation of the target\n       resource as provided by an intermediary.\n\n   3.  If the response has a Content-Location header field and its\n       field-value is a reference to the same URI as the effective\n       request URI, the payload is a representation of the resource\n       identified by the effective request URI.\n\n   4.  If the response has a Content-Location header field and its\n       field-value is a reference to a URI different from the effective\n       request URI, then the sender asserts that the payload is a\n       representation of the resource identified by the Content-Location\n       field-value.  However, such an assertion cannot be trusted unless\n       it can be verified by other means (not defined by this\n       specification).\n\n   5.  Otherwise, the payload is unidentified.\n\n3.1.4.2.  Content-Location\n\n   The \"Content-Location\" header field references a URI that can be used\n   as an identifier for a specific resource corresponding to the\n   representation in this message's payload.  In other words, if one\n   were to perform a GET request on this URI at the time of this\n   message's generation, then a 200 (OK) response would contain the same\n   representation that is enclosed as payload in this message.\n\n     Content-Location = absolute-URI / partial-URI\n\n   The Content-Location value is not a replacement for the effective\n   Request URI (SectionÂ 5.5 of [RFC7230]).  It is representation\n   metadata.  It has the same syntax and semantics as the header field\n   of the same name defined for MIME body parts in SectionÂ 4 of\n   [RFC2557].  However, its appearance in an HTTP message has some\n   special implications for HTTP recipients.\n\n\n\nFielding & Reschke           Standards Track                   [Page 15]\n"}],"position":{"start":{"line":843,"column":1,"offset":34314},"end":{"line":900,"column":4,"offset":36772}}}],"position":{"start":{"line":843,"column":1,"offset":34314},"end":{"line":900,"column":4,"offset":36772}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":902,"column":1,"offset":36774},"end":{"line":902,"column":4,"offset":36777}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   If Content-Location is included in a 2xx (Successful) response\n   message and its value refers (after conversion to absolute form) to a\n   URI that is the same as the effective request URI, then the recipient\n   MAY consider the payload to be a current representation of that\n   resource at the time indicated by the message origination date.  For\n   a GET (Section 4.3.1) or HEAD (Section 4.3.2) request, this is the\n   same as the default semantics when no Content-Location is provided by\n   the server.  For a state-changing request like PUT (Section 4.3.4) or\n   POST (Section 4.3.3), it implies that the server's response contains\n   the new representation of that resource, thereby distinguishing it\n   from representations that might only report about the action (e.g.,\n   \"It worked!\").  This allows authoring applications to update their\n   local copies without the need for a subsequent GET request.\n\n   If Content-Location is included in a 2xx (Successful) response\n   message and its field-value refers to a URI that differs from the\n   effective request URI, then the origin server claims that the URI is\n   an identifier for a different resource corresponding to the enclosed\n   representation.  Such a claim can only be trusted if both identifiers\n   share the same resource owner, which cannot be programmatically\n   determined via HTTP.\n\n   o  For a response to a GET or HEAD request, this is an indication\n      that the effective request URI refers to a resource that is\n      subject to content negotiation and the Content-Location\n      field-value is a more specific identifier for the selected\n      representation.\n\n   o  For a 201 (Created) response to a state-changing method, a\n      Content-Location field-value that is identical to the Location\n      field-value indicates that this payload is a current\n      representation of the newly created resource.\n\n   o  Otherwise, such a Content-Location indicates that this payload is\n      a representation reporting on the requested action's status and\n      that the same report is available (for future access with GET) at\n      the given URI.  For example, a purchase transaction made via a\n      POST request might include a receipt document as the payload of\n      the 200 (OK) response; the Content-Location field-value provides\n      an identifier for retrieving a copy of that same receipt in the\n      future.\n\n   A user agent that sends Content-Location in a request message is\n   stating that its value refers to where the user agent originally\n   obtained the content of the enclosed representation (prior to any\n   modifications made by that user agent).  In other words, the user\n   agent is providing a back link to the source of the original\n   representation.\n\n\n\nFielding & Reschke           Standards Track                   [Page 16]\n"}],"position":{"start":{"line":904,"column":1,"offset":36779},"end":{"line":961,"column":4,"offset":39693}}}],"position":{"start":{"line":904,"column":1,"offset":36779},"end":{"line":961,"column":4,"offset":39693}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":963,"column":1,"offset":39695},"end":{"line":963,"column":4,"offset":39698}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   An origin server that receives a Content-Location field in a request\n   message MUST treat the information as transitory request context\n   rather than as metadata to be saved verbatim as part of the\n   representation.  An origin server MAY use that context to guide in\n   processing the request or to save it for other uses, such as within\n   source links or versioning metadata.  However, an origin server MUST\n   NOT use such context information to alter the request semantics.\n\n   For example, if a client makes a PUT request on a negotiated resource\n   and the origin server accepts that PUT (without redirection), then\n   the new state of that resource is expected to be consistent with the\n   one representation supplied in that PUT; the Content-Location cannot\n   be used as a form of reverse content selection identifier to update\n   only one of the negotiated representations.  If the user agent had\n   wanted the latter semantics, it would have applied the PUT directly\n   to the Content-Location URI.\n\n3.2.  Representation Data\n\n   The representation data associated with an HTTP message is either\n   provided as the payload body of the message or referred to by the\n   message semantics and the effective request URI.  The representation\n   data is in a format and encoding defined by the representation\n   metadata header fields.\n\n   The data type of the representation data is determined via the header\n   fields Content-Type and Content-Encoding.  These define a two-layer,\n   ordered encoding model:\n\n     representation-data := Content-Encoding( Content-Type( bits ) )\n\n3.3.  Payload Semantics\n\n   Some HTTP messages transfer a complete or partial representation as\n   the message \"payload\".  In some cases, a payload might contain only\n   the associated representation's header fields (e.g., responses to\n   HEAD) or only some part(s) of the representation data (e.g., the 206\n   (Partial Content) status code).\n\n   The purpose of a payload in a request is defined by the method\n   semantics.  For example, a representation in the payload of a PUT\n   request (Section 4.3.4) represents the desired state of the target\n   resource if the request is successfully applied, whereas a\n   representation in the payload of a POST request (Section 4.3.3)\n   represents information to be processed by the target resource.\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 17]\n"}],"position":{"start":{"line":965,"column":1,"offset":39700},"end":{"line":1022,"column":4,"offset":42197}}}],"position":{"start":{"line":965,"column":1,"offset":39700},"end":{"line":1022,"column":4,"offset":42197}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1024,"column":1,"offset":42199},"end":{"line":1024,"column":4,"offset":42202}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   In a response, the payload's purpose is defined by both the request\n   method and the response status code.  For example, the payload of a\n   200 (OK) response to GET (Section 4.3.1) represents the current state\n   of the target resource, as observed at the time of the message\n   origination date (Section 7.1.1.2), whereas the payload of the same\n   status code in a response to POST might represent either the\n   processing result or the new state of the target resource after\n   applying the processing.  Response messages with an error status code\n   usually contain a payload that represents the error condition, such\n   that it describes the error state and what next steps are suggested\n   for resolving it.\n\n   Header fields that specifically describe the payload, rather than the\n   associated representation, are referred to as \"payload header\n   fields\".  Payload header fields are defined in other parts of this\n   specification, due to their impact on message parsing.\n\n   +-------------------+----------------------------+\n   | Header Field Name | Defined in...              |\n   +-------------------+----------------------------+\n   | Content-Length    | SectionÂ 3.3.2 of [RFC7230] |\n   | Content-Range     | SectionÂ 4.2 of [RFC7233]   |\n   | Trailer           | SectionÂ 4.4 of [RFC7230]   |\n   | Transfer-Encoding | SectionÂ 3.3.1 of [RFC7230] |\n   +-------------------+----------------------------+\n\n3.4.  Content Negotiation\n\n   When responses convey payload information, whether indicating a\n   success or an error, the origin server often has different ways of\n   representing that information; for example, in different formats,\n   languages, or encodings.  Likewise, different users or user agents\n   might have differing capabilities, characteristics, or preferences\n   that could influence which representation, among those available,\n   would be best to deliver.  For this reason, HTTP provides mechanisms\n   for content negotiation.\n\n   This specification defines two patterns of content negotiation that\n   can be made visible within the protocol: \"proactive\", where the\n   server selects the representation based upon the user agent's stated\n   preferences, and \"reactive\" negotiation, where the server provides a\n   list of representations for the user agent to choose from.  Other\n   patterns of content negotiation include \"conditional content\", where\n   the representation consists of multiple parts that are selectively\n   rendered based on user agent parameters, \"active content\", where the\n   representation contains a script that makes additional (more\n   specific) requests based on the user agent characteristics, and\n   \"Transparent Content Negotiation\" ([RFC2295]), where content\n\n\n\nFielding & Reschke           Standards Track                   [Page 18]\n"}],"position":{"start":{"line":1026,"column":1,"offset":42204},"end":{"line":1083,"column":4,"offset":45086}}}],"position":{"start":{"line":1026,"column":1,"offset":42204},"end":{"line":1083,"column":4,"offset":45086}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1085,"column":1,"offset":45088},"end":{"line":1085,"column":4,"offset":45091}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   selection is performed by an intermediary.  These patterns are not\n   mutually exclusive, and each has trade-offs in applicability and\n   practicality.\n\n   Note that, in all cases, HTTP is not aware of the resource semantics.\n   The consistency with which an origin server responds to requests,\n   over time and over the varying dimensions of content negotiation, and\n   thus the \"sameness\" of a resource's observed representations over\n   time, is determined entirely by whatever entity or algorithm selects\n   or generates those responses.  HTTP pays no attention to the man\n   behind the curtain.\n\n3.4.1.  Proactive Negotiation\n\n   When content negotiation preferences are sent by the user agent in a\n   request to encourage an algorithm located at the server to select the\n   preferred representation, it is called proactive negotiation (a.k.a.,\n   server-driven negotiation).  Selection is based on the available\n   representations for a response (the dimensions over which it might\n   vary, such as language, content-coding, etc.) compared to various\n   information supplied in the request, including both the explicit\n   negotiation fields of Section 5.3 and implicit characteristics, such\n   as the client's network address or parts of the User-Agent field.\n\n   Proactive negotiation is advantageous when the algorithm for\n   selecting from among the available representations is difficult to\n   describe to a user agent, or when the server desires to send its\n   \"best guess\" to the user agent along with the first response (hoping\n   to avoid the round trip delay of a subsequent request if the \"best\n   guess\" is good enough for the user).  In order to improve the\n   server's guess, a user agent MAY send request header fields that\n   describe its preferences.\n\n   Proactive negotiation has serious disadvantages:\n\n   o  It is impossible for the server to accurately determine what might\n      be \"best\" for any given user, since that would require complete\n      knowledge of both the capabilities of the user agent and the\n      intended use for the response (e.g., does the user want to view it\n      on screen or print it on paper?);\n\n   o  Having the user agent describe its capabilities in every request\n      can be both very inefficient (given that only a small percentage\n      of responses have multiple representations) and a potential risk\n      to the user's privacy;\n\n   o  It complicates the implementation of an origin server and the\n      algorithms for generating responses to a request; and,\n\n\n\nFielding & Reschke           Standards Track                   [Page 19]\n"}],"position":{"start":{"line":1087,"column":1,"offset":45093},"end":{"line":1144,"column":4,"offset":47778}}}],"position":{"start":{"line":1087,"column":1,"offset":45093},"end":{"line":1144,"column":4,"offset":47778}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1146,"column":1,"offset":47780},"end":{"line":1146,"column":4,"offset":47783}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   o  It limits the reusability of responses for shared caching.\n\n   A user agent cannot rely on proactive negotiation preferences being\n   consistently honored, since the origin server might not implement\n   proactive negotiation for the requested resource or might decide that\n   sending a response that doesn't conform to the user agent's\n   preferences is better than sending a 406 (Not Acceptable) response.\n\n   A Vary header field (Section 7.1.4) is often sent in a response\n   subject to proactive negotiation to indicate what parts of the\n   request information were used in the selection algorithm.\n\n3.4.2.  Reactive Negotiation\n\n   With reactive negotiation (a.k.a., agent-driven negotiation),\n   selection of the best response representation (regardless of the\n   status code) is performed by the user agent after receiving an\n   initial response from the origin server that contains a list of\n   resources for alternative representations.  If the user agent is not\n   satisfied by the initial response representation, it can perform a\n   GET request on one or more of the alternative resources, selected\n   based on metadata included in the list, to obtain a different form of\n   representation for that response.  Selection of alternatives might be\n   performed automatically by the user agent or manually by the user\n   selecting from a generated (possibly hypertext) menu.\n\n   Note that the above refers to representations of the response, in\n   general, not representations of the resource.  The alternative\n   representations are only considered representations of the target\n   resource if the response in which those alternatives are provided has\n   the semantics of being a representation of the target resource (e.g.,\n   a 200 (OK) response to a GET request) or has the semantics of\n   providing links to alternative representations for the target\n   resource (e.g., a 300 (Multiple Choices) response to a GET request).\n\n   A server might choose not to send an initial representation, other\n   than the list of alternatives, and thereby indicate that reactive\n   negotiation by the user agent is preferred.  For example, the\n   alternatives listed in responses with the 300 (Multiple Choices) and\n   406 (Not Acceptable) status codes include information about the\n   available representations so that the user or user agent can react by\n   making a selection.\n\n   Reactive negotiation is advantageous when the response would vary\n   over commonly used dimensions (such as type, language, or encoding),\n   when the origin server is unable to determine a user agent's\n   capabilities from examining the request, and generally when public\n   caches are used to distribute server load and reduce network usage.\n\n\n\nFielding & Reschke           Standards Track                   [Page 20]\n"}],"position":{"start":{"line":1148,"column":1,"offset":47785},"end":{"line":1205,"column":4,"offset":50672}}}],"position":{"start":{"line":1148,"column":1,"offset":47785},"end":{"line":1205,"column":4,"offset":50672}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1207,"column":1,"offset":50674},"end":{"line":1207,"column":4,"offset":50677}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Reactive negotiation suffers from the disadvantages of transmitting a\n   list of alternatives to the user agent, which degrades user-perceived\n   latency if transmitted in the header section, and needing a second\n   request to obtain an alternate representation.  Furthermore, this\n   specification does not define a mechanism for supporting automatic\n   selection, though it does not prevent such a mechanism from being\n   developed as an extension.\n\n4.  Request Methods\n\n4.1.  Overview\n\n   The request method token is the primary source of request semantics;\n   it indicates the purpose for which the client has made this request\n   and what is expected by the client as a successful result.\n\n   The request method's semantics might be further specialized by the\n   semantics of some header fields when present in a request (Section 5)\n   if those additional semantics do not conflict with the method.  For\n   example, a client can send conditional request header fields\n   (Section 5.2) to make the requested action conditional on the current\n   state of the target resource ([RFC7232]).\n\n     method = token\n\n   HTTP was originally designed to be usable as an interface to\n   distributed object systems.  The request method was envisioned as\n   applying semantics to a target resource in much the same way as\n   invoking a defined method on an identified object would apply\n   semantics.  The method token is case-sensitive because it might be\n   used as a gateway to object-based systems with case-sensitive method\n   names.\n\n   Unlike distributed objects, the standardized request methods in HTTP\n   are not resource-specific, since uniform interfaces provide for\n   better visibility and reuse in network-based systems [REST].  Once\n   defined, a standardized method ought to have the same semantics when\n   applied to any resource, though each resource determines for itself\n   whether those semantics are implemented or allowed.\n\n   This specification defines a number of standardized methods that are\n   commonly used in HTTP, as outlined by the following table.  By\n   convention, standardized methods are defined in all-uppercase\n   US-ASCII letters.\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 21]\n"}],"position":{"start":{"line":1209,"column":1,"offset":50679},"end":{"line":1266,"column":4,"offset":53008}}}],"position":{"start":{"line":1209,"column":1,"offset":50679},"end":{"line":1266,"column":4,"offset":53008}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1268,"column":1,"offset":53010},"end":{"line":1268,"column":4,"offset":53013}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   +---------+-------------------------------------------------+-------+\n   | Method  | Description                                     | Sec.  |\n   +---------+-------------------------------------------------+-------+\n   | GET     | Transfer a current representation of the target | 4.3.1 |\n   |         | resource.                                       |       |\n   | HEAD    | Same as GET, but only transfer the status line  | 4.3.2 |\n   |         | and header section.                             |       |\n   | POST    | Perform resource-specific processing on the     | 4.3.3 |\n   |         | request payload.                                |       |\n   | PUT     | Replace all current representations of the      | 4.3.4 |\n   |         | target resource with the request payload.       |       |\n   | DELETE  | Remove all current representations of the       | 4.3.5 |\n   |         | target resource.                                |       |\n   | CONNECT | Establish a tunnel to the server identified by  | 4.3.6 |\n   |         | the target resource.                            |       |\n   | OPTIONS | Describe the communication options for the      | 4.3.7 |\n   |         | target resource.                                |       |\n   | TRACE   | Perform a message loop-back test along the path | 4.3.8 |\n   |         | to the target resource.                         |       |\n   +---------+-------------------------------------------------+-------+\n\n   All general-purpose servers MUST support the methods GET and HEAD.\n   All other methods are OPTIONAL.\n\n   Additional methods, outside the scope of this specification, have\n   been standardized for use in HTTP.  All such methods ought to be\n   registered within the \"Hypertext Transfer Protocol (HTTP) Method\n   Registry\" maintained by IANA, as defined in Section 8.1.\n\n   The set of methods allowed by a target resource can be listed in an\n   Allow header field (Section 7.4.1).  However, the set of allowed\n   methods can change dynamically.  When a request method is received\n   that is unrecognized or not implemented by an origin server, the\n   origin server SHOULD respond with the 501 (Not Implemented) status\n   code.  When a request method is received that is known by an origin\n   server but not allowed for the target resource, the origin server\n   SHOULD respond with the 405 (Method Not Allowed) status code.\n\n4.2.  Common Method Properties\n\n4.2.1.  Safe Methods\n\n   Request methods are considered \"safe\" if their defined semantics are\n   essentially read-only; i.e., the client does not request, and does\n   not expect, any state change on the origin server as a result of\n   applying a safe method to a target resource.  Likewise, reasonable\n   use of a safe method is not expected to cause any harm, loss of\n   property, or unusual burden on the origin server.\n\n\n\nFielding & Reschke           Standards Track                   [Page 22]\n"}],"position":{"start":{"line":1270,"column":1,"offset":53015},"end":{"line":1327,"column":4,"offset":56014}}}],"position":{"start":{"line":1270,"column":1,"offset":53015},"end":{"line":1327,"column":4,"offset":56014}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1329,"column":1,"offset":56016},"end":{"line":1329,"column":4,"offset":56019}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   This definition of safe methods does not prevent an implementation\n   from including behavior that is potentially harmful, that is not\n   entirely read-only, or that causes side effects while invoking a safe\n   method.  What is important, however, is that the client did not\n   request that additional behavior and cannot be held accountable for\n   it.  For example, most servers append request information to access\n   log files at the completion of every response, regardless of the\n   method, and that is considered safe even though the log storage might\n   become full and crash the server.  Likewise, a safe request initiated\n   by selecting an advertisement on the Web will often have the side\n   effect of charging an advertising account.\n\n   Of the request methods defined by this specification, the GET, HEAD,\n   OPTIONS, and TRACE methods are defined to be safe.\n\n   The purpose of distinguishing between safe and unsafe methods is to\n   allow automated retrieval processes (spiders) and cache performance\n   optimization (pre-fetching) to work without fear of causing harm.  In\n   addition, it allows a user agent to apply appropriate constraints on\n   the automated use of unsafe methods when processing potentially\n   untrusted content.\n\n   A user agent SHOULD distinguish between safe and unsafe methods when\n   presenting potential actions to a user, such that the user can be\n   made aware of an unsafe action before it is requested.\n\n   When a resource is constructed such that parameters within the\n   effective request URI have the effect of selecting an action, it is\n   the resource owner's responsibility to ensure that the action is\n   consistent with the request method semantics.  For example, it is\n   common for Web-based content editing software to use actions within\n   query parameters, such as \"page?do=delete\".  If the purpose of such a\n   resource is to perform an unsafe action, then the resource owner MUST\n   disable or disallow that action when it is accessed using a safe\n   request method.  Failure to do so will result in unfortunate side\n   effects when automated processes perform a GET on every URI reference\n   for the sake of link maintenance, pre-fetching, building a search\n   index, etc.\n\n4.2.2.  Idempotent Methods\n\n   A request method is considered \"idempotent\" if the intended effect on\n   the server of multiple identical requests with that method is the\n   same as the effect for a single such request.  Of the request methods\n   defined by this specification, PUT, DELETE, and safe request methods\n   are idempotent.\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 23]\n"}],"position":{"start":{"line":1331,"column":1,"offset":56021},"end":{"line":1388,"column":4,"offset":58756}}}],"position":{"start":{"line":1331,"column":1,"offset":56021},"end":{"line":1388,"column":4,"offset":58756}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1390,"column":1,"offset":58758},"end":{"line":1390,"column":4,"offset":58761}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Like the definition of safe, the idempotent property only applies to\n   what has been requested by the user; a server is free to log each\n   request separately, retain a revision control history, or implement\n   other non-idempotent side effects for each idempotent request.\n\n   Idempotent methods are distinguished because the request can be\n   repeated automatically if a communication failure occurs before the\n   client is able to read the server's response.  For example, if a\n   client sends a PUT request and the underlying connection is closed\n   before any response is received, then the client can establish a new\n   connection and retry the idempotent request.  It knows that repeating\n   the request will have the same intended effect, even if the original\n   request succeeded, though the response might differ.\n\n4.2.3.  Cacheable Methods\n\n   Request methods can be defined as \"cacheable\" to indicate that\n   responses to them are allowed to be stored for future reuse; for\n   specific requirements see [RFC7234].  In general, safe methods that\n   do not depend on a current or authoritative response are defined as\n   cacheable; this specification defines GET, HEAD, and POST as\n   cacheable, although the overwhelming majority of cache\n   implementations only support GET and HEAD.\n\n4.3.  Method Definitions\n\n4.3.1.  GET\n\n   The GET method requests transfer of a current selected representation\n   for the target resource.  GET is the primary mechanism of information\n   retrieval and the focus of almost all performance optimizations.\n   Hence, when people speak of retrieving some identifiable information\n   via HTTP, they are generally referring to making a GET request.\n\n   It is tempting to think of resource identifiers as remote file system\n   pathnames and of representations as being a copy of the contents of\n   such files.  In fact, that is how many resources are implemented (see\n   Section 9.1 for related security considerations).  However, there are\n   no such limitations in practice.  The HTTP interface for a resource\n   is just as likely to be implemented as a tree of content objects, a\n   programmatic view on various database records, or a gateway to other\n   information systems.  Even when the URI mapping mechanism is tied to\n   a file system, an origin server might be configured to execute the\n   files with the request as input and send the output as the\n   representation rather than transfer the files directly.  Regardless,\n   only the origin server needs to know how each of its resource\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 24]\n"}],"position":{"start":{"line":1392,"column":1,"offset":58763},"end":{"line":1449,"column":4,"offset":61463}}}],"position":{"start":{"line":1392,"column":1,"offset":58763},"end":{"line":1449,"column":4,"offset":61463}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1451,"column":1,"offset":61465},"end":{"line":1451,"column":4,"offset":61468}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   identifiers corresponds to an implementation and how each\n   implementation manages to select and send a current representation of\n   the target resource in a response to GET.\n\n   A client can alter the semantics of GET to be a \"range request\",\n   requesting transfer of only some part(s) of the selected\n   representation, by sending a Range header field in the request\n   ([RFC7233]).\n\n   A payload within a GET request message has no defined semantics;\n   sending a payload body on a GET request might cause some existing\n   implementations to reject the request.\n\n   The response to a GET request is cacheable; a cache MAY use it to\n   satisfy subsequent GET and HEAD requests unless otherwise indicated\n   by the Cache-Control header field (SectionÂ 5.2 of [RFC7234]).\n\n4.3.2.  HEAD\n\n   The HEAD method is identical to GET except that the server MUST NOT\n   send a message body in the response (i.e., the response terminates at\n   the end of the header section).  The server SHOULD send the same\n   header fields in response to a HEAD request as it would have sent if\n   the request had been a GET, except that the payload header fields\n   (Section 3.3) MAY be omitted.  This method can be used for obtaining\n   metadata about the selected representation without transferring the\n   representation data and is often used for testing hypertext links for\n   validity, accessibility, and recent modification.\n\n   A payload within a HEAD request message has no defined semantics;\n   sending a payload body on a HEAD request might cause some existing\n   implementations to reject the request.\n\n   The response to a HEAD request is cacheable; a cache MAY use it to\n   satisfy subsequent HEAD requests unless otherwise indicated by the\n   Cache-Control header field (SectionÂ 5.2 of [RFC7234]).  A HEAD\n   response might also have an effect on previously cached responses to\n   GET; see SectionÂ 4.3.5 of [RFC7234].\n\n4.3.3.  POST\n\n   The POST method requests that the target resource process the\n   representation enclosed in the request according to the resource's\n   own specific semantics.  For example, POST is used for the following\n   functions (among others):\n\n   o  Providing a block of data, such as the fields entered into an HTML\n      form, to a data-handling process;\n\n\n\nFielding & Reschke           Standards Track                   [Page 25]\n"}],"position":{"start":{"line":1453,"column":1,"offset":61470},"end":{"line":1510,"column":4,"offset":63908}}}],"position":{"start":{"line":1453,"column":1,"offset":61470},"end":{"line":1510,"column":4,"offset":63908}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1512,"column":1,"offset":63910},"end":{"line":1512,"column":4,"offset":63913}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   o  Posting a message to a bulletin board, newsgroup, mailing list,\n      blog, or similar group of articles;\n\n   o  Creating a new resource that has yet to be identified by the\n      origin server; and\n\n   o  Appending data to a resource's existing representation(s).\n\n   An origin server indicates response semantics by choosing an\n   appropriate status code depending on the result of processing the\n   POST request; almost all of the status codes defined by this\n   specification might be received in a response to POST (the exceptions\n   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not\n   Satisfiable)).\n\n   If one or more resources has been created on the origin server as a\n   result of successfully processing a POST request, the origin server\n   SHOULD send a 201 (Created) response containing a Location header\n   field that provides an identifier for the primary resource created\n   (Section 7.1.2) and a representation that describes the status of the\n   request while referring to the new resource(s).\n\n   Responses to POST requests are only cacheable when they include\n   explicit freshness information (see SectionÂ 4.2.1 of [RFC7234]).\n   However, POST caching is not widely implemented.  For cases where an\n   origin server wishes the client to be able to cache the result of a\n   POST in a way that can be reused by a later GET, the origin server\n   MAY send a 200 (OK) response containing the result and a\n   Content-Location header field that has the same value as the POST's\n   effective request URI (Section 3.1.4.2).\n\n   If the result of processing a POST would be equivalent to a\n   representation of an existing resource, an origin server MAY redirect\n   the user agent to that resource by sending a 303 (See Other) response\n   with the existing resource's identifier in the Location field.  This\n   has the benefits of providing the user agent a resource identifier\n   and transferring the representation via a method more amenable to\n   shared caching, though at the cost of an extra request if the user\n   agent does not already have the representation cached.\n\n4.3.4.  PUT\n\n   The PUT method requests that the state of the target resource be\n   created or replaced with the state defined by the representation\n   enclosed in the request message payload.  A successful PUT of a given\n   representation would suggest that a subsequent GET on that same\n   target resource will result in an equivalent representation being\n   sent in a 200 (OK) response.  However, there is no guarantee that\n\n\n\nFielding & Reschke           Standards Track                   [Page 26]\n"}],"position":{"start":{"line":1514,"column":1,"offset":63915},"end":{"line":1571,"column":4,"offset":66612}}}],"position":{"start":{"line":1514,"column":1,"offset":63915},"end":{"line":1571,"column":4,"offset":66612}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1573,"column":1,"offset":66614},"end":{"line":1573,"column":4,"offset":66617}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   such a state change will be observable, since the target resource\n   might be acted upon by other user agents in parallel, or might be\n   subject to dynamic processing by the origin server, before any\n   subsequent GET is received.  A successful response only implies that\n   the user agent's intent was achieved at the time of its processing by\n   the origin server.\n\n   If the target resource does not have a current representation and the\n   PUT successfully creates one, then the origin server MUST inform the\n   user agent by sending a 201 (Created) response.  If the target\n   resource does have a current representation and that representation\n   is successfully modified in accordance with the state of the enclosed\n   representation, then the origin server MUST send either a 200 (OK) or\n   a 204 (No Content) response to indicate successful completion of the\n   request.\n\n   An origin server SHOULD ignore unrecognized header fields received in\n   a PUT request (i.e., do not save them as part of the resource state).\n\n   An origin server SHOULD verify that the PUT representation is\n   consistent with any constraints the server has for the target\n   resource that cannot or will not be changed by the PUT.  This is\n   particularly important when the origin server uses internal\n   configuration information related to the URI in order to set the\n   values for representation metadata on GET responses.  When a PUT\n   representation is inconsistent with the target resource, the origin\n   server SHOULD either make them consistent, by transforming the\n   representation or changing the resource configuration, or respond\n   with an appropriate error message containing sufficient information\n   to explain why the representation is unsuitable.  The 409 (Conflict)\n   or 415 (Unsupported Media Type) status codes are suggested, with the\n   latter being specific to constraints on Content-Type values.\n\n   For example, if the target resource is configured to always have a\n   Content-Type of \"text/html\" and the representation being PUT has a\n   Content-Type of \"image/jpeg\", the origin server ought to do one of:\n\n   a.  reconfigure the target resource to reflect the new media type;\n\n   b.  transform the PUT representation to a format consistent with that\n       of the resource before saving it as the new resource state; or,\n\n   c.  reject the request with a 415 (Unsupported Media Type) response\n       indicating that the target resource is limited to \"text/html\",\n       perhaps including a link to a different resource that would be a\n       suitable target for the new representation.\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 27]\n"}],"position":{"start":{"line":1575,"column":1,"offset":66619},"end":{"line":1632,"column":4,"offset":69387}}}],"position":{"start":{"line":1575,"column":1,"offset":66619},"end":{"line":1632,"column":4,"offset":69387}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1634,"column":1,"offset":69389},"end":{"line":1634,"column":4,"offset":69392}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   HTTP does not define exactly how a PUT method affects the state of an\n   origin server beyond what can be expressed by the intent of the user\n   agent request and the semantics of the origin server response.  It\n   does not define what a resource might be, in any sense of that word,\n   beyond the interface provided via HTTP.  It does not define how\n   resource state is \"stored\", nor how such storage might change as a\n   result of a change in resource state, nor how the origin server\n   translates resource state into representations.  Generally speaking,\n   all implementation details behind the resource interface are\n   intentionally hidden by the server.\n\n   An origin server MUST NOT send a validator header field\n   (Section 7.2), such as an ETag or Last-Modified field, in a\n   successful response to PUT unless the request's representation data\n   was saved without any transformation applied to the body (i.e., the\n   resource's new representation data is identical to the representation\n   data received in the PUT request) and the validator field value\n   reflects the new representation.  This requirement allows a user\n   agent to know when the representation body it has in memory remains\n   current as a result of the PUT, thus not in need of being retrieved\n   again from the origin server, and that the new validator(s) received\n   in the response can be used for future conditional requests in order\n   to prevent accidental overwrites (Section 5.2).\n\n   The fundamental difference between the POST and PUT methods is\n   highlighted by the different intent for the enclosed representation.\n   The target resource in a POST request is intended to handle the\n   enclosed representation according to the resource's own semantics,\n   whereas the enclosed representation in a PUT request is defined as\n   replacing the state of the target resource.  Hence, the intent of PUT\n   is idempotent and visible to intermediaries, even though the exact\n   effect is only known by the origin server.\n\n   Proper interpretation of a PUT request presumes that the user agent\n   knows which target resource is desired.  A service that selects a\n   proper URI on behalf of the client, after receiving a state-changing\n   request, SHOULD be implemented using the POST method rather than PUT.\n   If the origin server will not make the requested PUT state change to\n   the target resource and instead wishes to have it applied to a\n   different resource, such as when the resource has been moved to a\n   different URI, then the origin server MUST send an appropriate 3xx\n   (Redirection) response; the user agent MAY then make its own decision\n   regarding whether or not to redirect the request.\n\n   A PUT request applied to the target resource can have side effects on\n   other resources.  For example, an article might have a URI for\n   identifying \"the current version\" (a resource) that is separate from\n   the URIs identifying each particular version (different resources\n\n\n\nFielding & Reschke           Standards Track                   [Page 28]\n"}],"position":{"start":{"line":1636,"column":1,"offset":69394},"end":{"line":1693,"column":4,"offset":72534}}}],"position":{"start":{"line":1636,"column":1,"offset":69394},"end":{"line":1693,"column":4,"offset":72534}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1695,"column":1,"offset":72536},"end":{"line":1695,"column":4,"offset":72539}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   that at one point shared the same state as the current version\n   resource).  A successful PUT request on \"the current version\" URI\n   might therefore create a new version resource in addition to changing\n   the state of the target resource, and might also cause links to be\n   added between the related resources.\n\n   An origin server that allows PUT on a given target resource MUST send\n   a 400 (Bad Request) response to a PUT request that contains a\n   Content-Range header field (SectionÂ 4.2 of [RFC7233]), since the\n   payload is likely to be partial content that has been mistakenly PUT\n   as a full representation.  Partial content updates are possible by\n   targeting a separately identified resource with state that overlaps a\n   portion of the larger resource, or by using a different method that\n   has been specifically defined for partial updates (for example, the\n   PATCH method defined in [RFC5789]).\n\n   Responses to the PUT method are not cacheable.  If a successful PUT\n   request passes through a cache that has one or more stored responses\n   for the effective request URI, those stored responses will be\n   invalidated (see SectionÂ 4.4 of [RFC7234]).\n\n4.3.5.  DELETE\n\n   The DELETE method requests that the origin server remove the\n   association between the target resource and its current\n   functionality.  In effect, this method is similar to the rm command\n   in UNIX: it expresses a deletion operation on the URI mapping of the\n   origin server rather than an expectation that the previously\n   associated information be deleted.\n\n   If the target resource has one or more current representations, they\n   might or might not be destroyed by the origin server, and the\n   associated storage might or might not be reclaimed, depending\n   entirely on the nature of the resource and its implementation by the\n   origin server (which are beyond the scope of this specification).\n   Likewise, other implementation aspects of a resource might need to be\n   deactivated or archived as a result of a DELETE, such as database or\n   gateway connections.  In general, it is assumed that the origin\n   server will only allow DELETE on resources for which it has a\n   prescribed mechanism for accomplishing the deletion.\n\n   Relatively few resources allow the DELETE method -- its primary use\n   is for remote authoring environments, where the user has some\n   direction regarding its effect.  For example, a resource that was\n   previously created using a PUT request, or identified via the\n   Location header field after a 201 (Created) response to a POST\n   request, might allow a corresponding DELETE request to undo those\n   actions.  Similarly, custom user agent implementations that implement\n\n\n\nFielding & Reschke           Standards Track                   [Page 29]\n"}],"position":{"start":{"line":1697,"column":1,"offset":72541},"end":{"line":1754,"column":4,"offset":75418}}}],"position":{"start":{"line":1697,"column":1,"offset":72541},"end":{"line":1754,"column":4,"offset":75418}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1756,"column":1,"offset":75420},"end":{"line":1756,"column":4,"offset":75423}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   an authoring function, such as revision control clients using HTTP\n   for remote operations, might use DELETE based on an assumption that\n   the server's URI space has been crafted to correspond to a version\n   repository.\n\n   If a DELETE method is successfully applied, the origin server SHOULD\n   send a 202 (Accepted) status code if the action will likely succeed\n   but has not yet been enacted, a 204 (No Content) status code if the\n   action has been enacted and no further information is to be supplied,\n   or a 200 (OK) status code if the action has been enacted and the\n   response message includes a representation describing the status.\n\n   A payload within a DELETE request message has no defined semantics;\n   sending a payload body on a DELETE request might cause some existing\n   implementations to reject the request.\n\n   Responses to the DELETE method are not cacheable.  If a DELETE\n   request passes through a cache that has one or more stored responses\n   for the effective request URI, those stored responses will be\n   invalidated (see SectionÂ 4.4 of [RFC7234]).\n\n4.3.6.  CONNECT\n\n   The CONNECT method requests that the recipient establish a tunnel to\n   the destination origin server identified by the request-target and,\n   if successful, thereafter restrict its behavior to blind forwarding\n   of packets, in both directions, until the tunnel is closed.  Tunnels\n   are commonly used to create an end-to-end virtual connection, through\n   one or more proxies, which can then be secured using TLS (Transport\n   Layer Security, [RFC5246]).\n\n   CONNECT is intended only for use in requests to a proxy.  An origin\n   server that receives a CONNECT request for itself MAY respond with a\n   2xx (Successful) status code to indicate that a connection is\n   established.  However, most origin servers do not implement CONNECT.\n\n   A client sending a CONNECT request MUST send the authority form of\n   request-target (SectionÂ 5.3 of [RFC7230]); i.e., the request-target\n   consists of only the host name and port number of the tunnel\n   destination, separated by a colon.  For example,\n\n     CONNECT server.example.com:80 HTTP/1.1\n     Host: server.example.com:80\n\n   The recipient proxy can establish a tunnel either by directly\n   connecting to the request-target or, if configured to use another\n   proxy, by forwarding the CONNECT request to the next inbound proxy.\n   Any 2xx (Successful) response indicates that the sender (and all\n\n\n\nFielding & Reschke           Standards Track                   [Page 30]\n"}],"position":{"start":{"line":1758,"column":1,"offset":75425},"end":{"line":1815,"column":4,"offset":78042}}}],"position":{"start":{"line":1758,"column":1,"offset":75425},"end":{"line":1815,"column":4,"offset":78042}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1817,"column":1,"offset":78044},"end":{"line":1817,"column":4,"offset":78047}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   inbound proxies) will switch to tunnel mode immediately after the\n   blank line that concludes the successful response's header section;\n   data received after that blank line is from the server identified by\n   the request-target.  Any response other than a successful response\n   indicates that the tunnel has not yet been formed and that the\n   connection remains governed by HTTP.\n\n   A tunnel is closed when a tunnel intermediary detects that either\n   side has closed its connection: the intermediary MUST attempt to send\n   any outstanding data that came from the closed side to the other\n   side, close both connections, and then discard any remaining data\n   left undelivered.\n\n   Proxy authentication might be used to establish the authority to\n   create a tunnel.  For example,\n\n     CONNECT server.example.com:80 HTTP/1.1\n     Host: server.example.com:80\n     Proxy-Authorization: basic aGVsbG86d29ybGQ=\n\n   There are significant risks in establishing a tunnel to arbitrary\n   servers, particularly when the destination is a well-known or\n   reserved TCP port that is not intended for Web traffic.  For example,\n   a CONNECT to a request-target of \"example.com:25\" would suggest that\n   the proxy connect to the reserved port for SMTP traffic; if allowed,\n   that could trick the proxy into relaying spam email.  Proxies that\n   support CONNECT SHOULD restrict its use to a limited set of known\n   ports or a configurable whitelist of safe request targets.\n\n   A server MUST NOT send any Transfer-Encoding or Content-Length header\n   fields in a 2xx (Successful) response to CONNECT.  A client MUST\n   ignore any Content-Length or Transfer-Encoding header fields received\n   in a successful response to CONNECT.\n\n   A payload within a CONNECT request message has no defined semantics;\n   sending a payload body on a CONNECT request might cause some existing\n   implementations to reject the request.\n\n   Responses to the CONNECT method are not cacheable.\n\n4.3.7.  OPTIONS\n\n   The OPTIONS method requests information about the communication\n   options available for the target resource, at either the origin\n   server or an intervening intermediary.  This method allows a client\n   to determine the options and/or requirements associated with a\n   resource, or the capabilities of a server, without implying a\n   resource action.\n\n\n\nFielding & Reschke           Standards Track                   [Page 31]\n"}],"position":{"start":{"line":1819,"column":1,"offset":78049},"end":{"line":1876,"column":4,"offset":80552}}}],"position":{"start":{"line":1819,"column":1,"offset":78049},"end":{"line":1876,"column":4,"offset":80552}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1878,"column":1,"offset":80554},"end":{"line":1878,"column":4,"offset":80557}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   An OPTIONS request with an asterisk (\"*\") as the request-target\n   (SectionÂ 5.3 of [RFC7230]) applies to the server in general rather\n   than to a specific resource.  Since a server's communication options\n   typically depend on the resource, the \"*\" request is only useful as a\n   \"ping\" or \"no-op\" type of method; it does nothing beyond allowing the\n   client to test the capabilities of the server.  For example, this can\n   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).\n\n   If the request-target is not an asterisk, the OPTIONS request applies\n   to the options that are available when communicating with the target\n   resource.\n\n   A server generating a successful response to OPTIONS SHOULD send any\n   header fields that might indicate optional features implemented by\n   the server and applicable to the target resource (e.g., Allow),\n   including potential extensions not defined by this specification.\n   The response payload, if any, might also describe the communication\n   options in a machine or human-readable representation.  A standard\n   format for such a representation is not defined by this\n   specification, but might be defined by future extensions to HTTP.  A\n   server MUST generate a Content-Length field with a value of \"0\" if no\n   payload body is to be sent in the response.\n\n   A client MAY send a Max-Forwards header field in an OPTIONS request\n   to target a specific recipient in the request chain (see\n   Section 5.1.2).  A proxy MUST NOT generate a Max-Forwards header\n   field while forwarding a request unless that request was received\n   with a Max-Forwards field.\n\n   A client that generates an OPTIONS request containing a payload body\n   MUST send a valid Content-Type header field describing the\n   representation media type.  Although this specification does not\n   define any use for such a payload, future extensions to HTTP might\n   use the OPTIONS body to make more detailed queries about the target\n   resource.\n\n   Responses to the OPTIONS method are not cacheable.\n\n4.3.8.  TRACE\n\n   The TRACE method requests a remote, application-level loop-back of\n   the request message.  The final recipient of the request SHOULD\n   reflect the message received, excluding some fields described below,\n   back to the client as the message body of a 200 (OK) response with a\n   Content-Type of \"message/http\" (SectionÂ 8.3.1 of [RFC7230]).  The\n   final recipient is either the origin server or the first server to\n   receive a Max-Forwards value of zero (0) in the request\n   (Section 5.1.2).\n\n\n\nFielding & Reschke           Standards Track                   [Page 32]\n"}],"position":{"start":{"line":1880,"column":1,"offset":80559},"end":{"line":1937,"column":4,"offset":83273}}}],"position":{"start":{"line":1880,"column":1,"offset":80559},"end":{"line":1937,"column":4,"offset":83273}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":1939,"column":1,"offset":83275},"end":{"line":1939,"column":4,"offset":83278}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   A client MUST NOT generate header fields in a TRACE request\n   containing sensitive data that might be disclosed by the response.\n   For example, it would be foolish for a user agent to send stored user\n   credentials [RFC7235] or cookies [RFC6265] in a TRACE request.  The\n   final recipient of the request SHOULD exclude any request header\n   fields that are likely to contain sensitive data when that recipient\n   generates the response body.\n\n   TRACE allows the client to see what is being received at the other\n   end of the request chain and use that data for testing or diagnostic\n   information.  The value of the Via header field (SectionÂ 5.7.1 of\n   [RFC7230]) is of particular interest, since it acts as a trace of the\n   request chain.  Use of the Max-Forwards header field allows the\n   client to limit the length of the request chain, which is useful for\n   testing a chain of proxies forwarding messages in an infinite loop.\n\n   A client MUST NOT send a message body in a TRACE request.\n\n   Responses to the TRACE method are not cacheable.\n\n5.  Request Header Fields\n\n   A client sends request header fields to provide more information\n   about the request context, make the request conditional based on the\n   target resource state, suggest preferred formats for the response,\n   supply authentication credentials, or modify the expected request\n   processing.  These fields act as request modifiers, similar to the\n   parameters on a programming language method invocation.\n\n5.1.  Controls\n\n   Controls are request header fields that direct specific handling of\n   the request.\n\n   +-------------------+--------------------------+\n   | Header Field Name | Defined in...            |\n   +-------------------+--------------------------+\n   | Cache-Control     | SectionÂ 5.2 of [RFC7234] |\n   | Expect            | Section 5.1.1            |\n   | Host              | SectionÂ 5.4 of [RFC7230] |\n   | Max-Forwards      | Section 5.1.2            |\n   | Pragma            | SectionÂ 5.4 of [RFC7234] |\n   | Range             | SectionÂ 3.1 of [RFC7233] |\n   | TE                | SectionÂ 4.3 of [RFC7230] |\n   +-------------------+--------------------------+\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 33]\n"}],"position":{"start":{"line":1941,"column":1,"offset":83280},"end":{"line":1998,"column":4,"offset":85614}}}],"position":{"start":{"line":1941,"column":1,"offset":83280},"end":{"line":1998,"column":4,"offset":85614}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2000,"column":1,"offset":85616},"end":{"line":2000,"column":4,"offset":85619}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n5.1.1.  Expect\n\n   The \"Expect\" header field in a request indicates a certain set of\n   behaviors (expectations) that need to be supported by the server in\n   order to properly handle this request.  The only such expectation\n   defined by this specification is 100-continue.\n\n     Expect  = \"100-continue\"\n\n   The Expect field-value is case-insensitive.\n\n   A server that receives an Expect field-value other than 100-continue\n   MAY respond with a 417 (Expectation Failed) status code to indicate\n   that the unexpected expectation cannot be met.\n\n   A 100-continue expectation informs recipients that the client is\n   about to send a (presumably large) message body in this request and\n   wishes to receive a 100 (Continue) interim response if the\n   request-line and header fields are not sufficient to cause an\n   immediate success, redirect, or error response.  This allows the\n   client to wait for an indication that it is worthwhile to send the\n   message body before actually doing so, which can improve efficiency\n   when the message body is huge or when the client anticipates that an\n   error is likely (e.g., when sending a state-changing method, for the\n   first time, without previously verified authentication credentials).\n\n   For example, a request that begins with\n\n     PUT /somewhere/fun HTTP/1.1\n     Host: origin.example.com\n     Content-Type: video/h264\n     Content-Length: 1234567890987\n     Expect: 100-continue\n\n\n   allows the origin server to immediately respond with an error\n   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),\n   before the client starts filling the pipes with an unnecessary data\n   transfer.\n\n   Requirements for clients:\n\n   o  A client MUST NOT generate a 100-continue expectation in a request\n      that does not include a message body.\n\n   o  A client that will wait for a 100 (Continue) response before\n      sending the request message body MUST send an Expect header field\n      containing a 100-continue expectation.\n\n\n\nFielding & Reschke           Standards Track                   [Page 34]\n"}],"position":{"start":{"line":2002,"column":1,"offset":85621},"end":{"line":2059,"column":4,"offset":87771}}}],"position":{"start":{"line":2002,"column":1,"offset":85621},"end":{"line":2059,"column":4,"offset":87771}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2061,"column":1,"offset":87773},"end":{"line":2061,"column":4,"offset":87776}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   o  A client that sends a 100-continue expectation is not required to\n      wait for any specific length of time; such a client MAY proceed to\n      send the message body even if it has not yet received a response.\n      Furthermore, since 100 (Continue) responses cannot be sent through\n      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an\n      indefinite period before sending the message body.\n\n   o  A client that receives a 417 (Expectation Failed) status code in\n      response to a request containing a 100-continue expectation SHOULD\n      repeat that request without a 100-continue expectation, since the\n      417 response merely indicates that the response chain does not\n      support expectations (e.g., it passes through an HTTP/1.0 server).\n\n   Requirements for servers:\n\n   o  A server that receives a 100-continue expectation in an HTTP/1.0\n      request MUST ignore that expectation.\n\n   o  A server MAY omit sending a 100 (Continue) response if it has\n      already received some or all of the message body for the\n      corresponding request, or if the framing indicates that there is\n      no message body.\n\n   o  A server that sends a 100 (Continue) response MUST ultimately send\n      a final status code, once the message body is received and\n      processed, unless the connection is closed prematurely.\n\n   o  A server that responds with a final status code before reading the\n      entire message body SHOULD indicate in that response whether it\n      intends to close the connection or continue reading and discarding\n      the request message (see SectionÂ 6.6 of [RFC7230]).\n\n   An origin server MUST, upon receiving an HTTP/1.1 (or later)\n   request-line and a complete header section that contains a\n   100-continue expectation and indicates a request message body will\n   follow, either send an immediate response with a final status code,\n   if that status can be determined by examining just the request-line\n   and header fields, or send an immediate 100 (Continue) response to\n   encourage the client to send the request's message body.  The origin\n   server MUST NOT wait for the message body before sending the 100\n   (Continue) response.\n\n   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and\n   a complete header section that contains a 100-continue expectation\n   and indicates a request message body will follow, either send an\n   immediate response with a final status code, if that status can be\n   determined by examining just the request-line and header fields, or\n   begin forwarding the request toward the origin server by sending a\n\n\n\nFielding & Reschke           Standards Track                   [Page 35]\n"}],"position":{"start":{"line":2063,"column":1,"offset":87778},"end":{"line":2120,"column":4,"offset":90555}}}],"position":{"start":{"line":2063,"column":1,"offset":87778},"end":{"line":2120,"column":4,"offset":90555}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2122,"column":1,"offset":90557},"end":{"line":2122,"column":4,"offset":90560}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   corresponding request-line and header section to the next inbound\n   server.  If the proxy believes (from configuration or past\n   interaction) that the next inbound server only supports HTTP/1.0, the\n   proxy MAY generate an immediate 100 (Continue) response to encourage\n   the client to begin sending the message body.\n\n      Note: The Expect header field was added after the original\n      publication of HTTP/1.1 [RFC2068] as both the means to request an\n      interim 100 (Continue) response and the general mechanism for\n      indicating must-understand extensions.  However, the extension\n      mechanism has not been used by clients and the must-understand\n      requirements have not been implemented by many servers, rendering\n      the extension mechanism useless.  This specification has removed\n      the extension mechanism in order to simplify the definition and\n      processing of 100-continue.\n\n5.1.2.  Max-Forwards\n\n   The \"Max-Forwards\" header field provides a mechanism with the TRACE\n   (Section 4.3.8) and OPTIONS (Section 4.3.7) request methods to limit\n   the number of times that the request is forwarded by proxies.  This\n   can be useful when the client is attempting to trace a request that\n   appears to be failing or looping mid-chain.\n\n     Max-Forwards = 1*DIGIT\n\n   The Max-Forwards value is a decimal integer indicating the remaining\n   number of times this request message can be forwarded.\n\n   Each intermediary that receives a TRACE or OPTIONS request containing\n   a Max-Forwards header field MUST check and update its value prior to\n   forwarding the request.  If the received value is zero (0), the\n   intermediary MUST NOT forward the request; instead, the intermediary\n   MUST respond as the final recipient.  If the received Max-Forwards\n   value is greater than zero, the intermediary MUST generate an updated\n   Max-Forwards field in the forwarded message with a field-value that\n   is the lesser of a) the received value decremented by one (1) or b)\n   the recipient's maximum supported value for Max-Forwards.\n\n   A recipient MAY ignore a Max-Forwards header field received with any\n   other request methods.\n\n5.2.  Conditionals\n\n   The HTTP conditional request header fields [RFC7232] allow a client\n   to place a precondition on the state of the target resource, so that\n   the action corresponding to the method semantics will not be applied\n   if the precondition evaluates to false.  Each precondition defined by\n\n\n\nFielding & Reschke           Standards Track                   [Page 36]\n"}],"position":{"start":{"line":2124,"column":1,"offset":90562},"end":{"line":2181,"column":4,"offset":93191}}}],"position":{"start":{"line":2124,"column":1,"offset":90562},"end":{"line":2181,"column":4,"offset":93191}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2183,"column":1,"offset":93193},"end":{"line":2183,"column":4,"offset":93196}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   this specification consists of a comparison between a set of\n   validators obtained from prior representations of the target resource\n   to the current state of validators for the selected representation\n   (Section 7.2).  Hence, these preconditions evaluate whether the state\n   of the target resource has changed since a given state known by the\n   client.  The effect of such an evaluation depends on the method\n   semantics and choice of conditional, as defined in SectionÂ 5 of\n   [RFC7232].\n\n   +---------------------+--------------------------+\n   | Header Field Name   | Defined in...            |\n   +---------------------+--------------------------+\n   | If-Match            | SectionÂ 3.1 of [RFC7232] |\n   | If-None-Match       | SectionÂ 3.2 of [RFC7232] |\n   | If-Modified-Since   | SectionÂ 3.3 of [RFC7232] |\n   | If-Unmodified-Since | SectionÂ 3.4 of [RFC7232] |\n   | If-Range            | SectionÂ 3.2 of [RFC7233] |\n   +---------------------+--------------------------+\n\n5.3.  Content Negotiation\n\n   The following request header fields are sent by a user agent to\n   engage in proactive negotiation of the response content, as defined\n   in Section 3.4.1.  The preferences sent in these fields apply to any\n   content in the response, including representations of the target\n   resource, representations of error or processing status, and\n   potentially even the miscellaneous text strings that might appear\n   within the protocol.\n\n   +-------------------+---------------+\n   | Header Field Name | Defined in... |\n   +-------------------+---------------+\n   | Accept            | Section 5.3.2 |\n   | Accept-Charset    | Section 5.3.3 |\n   | Accept-Encoding   | Section 5.3.4 |\n   | Accept-Language   | Section 5.3.5 |\n   +-------------------+---------------+\n\n5.3.1.  Quality Values\n\n   Many of the request header fields for proactive negotiation use a\n   common parameter, named \"q\" (case-insensitive), to assign a relative\n   \"weight\" to the preference for that associated kind of content.  This\n   weight is referred to as a \"quality value\" (or \"qvalue\") because the\n   same parameter name is often used within server configurations to\n   assign a weight to the relative quality of the various\n   representations that can be selected for a resource.\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 37]\n"}],"position":{"start":{"line":2185,"column":1,"offset":93198},"end":{"line":2242,"column":4,"offset":95630}}}],"position":{"start":{"line":2185,"column":1,"offset":93198},"end":{"line":2242,"column":4,"offset":95630}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2244,"column":1,"offset":95632},"end":{"line":2244,"column":4,"offset":95635}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   The weight is normalized to a real number in the range 0 through 1,\n   where 0.001 is the least preferred and 1 is the most preferred; a\n   value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n   the default weight is 1.\n\n     weight = OWS \";\" OWS \"q=\" qvalue\n     qvalue = ( \"0\" [ \".\" 0*3DIGIT ] )\n            / ( \"1\" [ \".\" 0*3(\"0\") ] )\n\n   A sender of qvalue MUST NOT generate more than three digits after the\n   decimal point.  User configuration of these values ought to be\n   limited in the same fashion.\n\n5.3.2.  Accept\n\n   The \"Accept\" header field can be used by user agents to specify\n   response media types that are acceptable.  Accept header fields can\n   be used to indicate that the request is specifically limited to a\n   small set of desired types, as in the case of a request for an\n   in-line image.\n\n     Accept = #( media-range [ accept-params ] )\n\n     media-range    = ( \"*/*\"\n                      / ( type \"/\" \"*\" )\n                      / ( type \"/\" subtype )\n                      ) *( OWS \";\" OWS parameter )\n     accept-params  = weight *( accept-ext )\n     accept-ext = OWS \";\" OWS token [ \"=\" ( token / quoted-string ) ]\n\n   The asterisk \"*\" character is used to group media types into ranges,\n   with \"*/*\" indicating all media types and \"type/*\" indicating all\n   subtypes of that type.  The media-range can include media type\n   parameters that are applicable to that range.\n\n   Each media-range might be followed by zero or more applicable media\n   type parameters (e.g., charset), an optional \"q\" parameter for\n   indicating a relative weight (Section 5.3.1), and then zero or more\n   extension parameters.  The \"q\" parameter is necessary if any\n   extensions (accept-ext) are present, since it acts as a separator\n   between the two parameter sets.\n\n      Note: Use of the \"q\" parameter name to separate media type\n      parameters from Accept extension parameters is due to historical\n      practice.  Although this prevents any media type parameter named\n      \"q\" from being used with a media range, such an event is believed\n      to be unlikely given the lack of any \"q\" parameters in the IANA\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 38]\n"}],"position":{"start":{"line":2246,"column":1,"offset":95637},"end":{"line":2303,"column":4,"offset":97950}}}],"position":{"start":{"line":2246,"column":1,"offset":95637},"end":{"line":2303,"column":4,"offset":97950}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2305,"column":1,"offset":97952},"end":{"line":2305,"column":4,"offset":97955}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n      media type registry and the rare usage of any media type\n      parameters in Accept.  Future media types are discouraged from\n      registering any parameter named \"q\".\n\n   The example\n\n     Accept: audio/*; q=0.2, audio/basic\n\n   is interpreted as \"I prefer audio/basic, but send me any audio type\n   if it is the best available after an 80% markdown in quality\".\n\n   A request without any Accept header field implies that the user agent\n   will accept any media type in response.  If the header field is\n   present in a request and none of the available representations for\n   the response have a media type that is listed as acceptable, the\n   origin server can either honor the header field by sending a 406 (Not\n   Acceptable) response or disregard the header field by treating the\n   response as if it is not subject to content negotiation.\n\n   A more elaborate example is\n\n     Accept: text/plain; q=0.5, text/html,\n             text/x-dvi; q=0.8, text/x-c\n\n   Verbally, this would be interpreted as \"text/html and text/x-c are\n   the equally preferred media types, but if they do not exist, then\n   send the text/x-dvi representation, and if that does not exist, send\n   the text/plain representation\".\n\n   Media ranges can be overridden by more specific media ranges or\n   specific media types.  If more than one media range applies to a\n   given type, the most specific reference has precedence.  For example,\n\n     Accept: text/*, text/plain, text/plain;format=flowed, */*\n\n   have the following precedence:\n\n   1.  text/plain;format=flowed\n\n   2.  text/plain\n\n   3.  text/*\n\n   4.  */*\n\n   The media type quality factor associated with a given type is\n   determined by finding the media range with the highest precedence\n   that matches the type.  For example,\n\n\n\nFielding & Reschke           Standards Track                   [Page 39]\n"}],"position":{"start":{"line":2307,"column":1,"offset":97957},"end":{"line":2364,"column":4,"offset":99895}}}],"position":{"start":{"line":2307,"column":1,"offset":97957},"end":{"line":2364,"column":4,"offset":99895}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2366,"column":1,"offset":99897},"end":{"line":2366,"column":4,"offset":99900}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\n             text/html;level=2;q=0.4, */*;q=0.5\n\n   would cause the following values to be associated:\n\n   +-------------------+---------------+\n   | Media Type        | Quality Value |\n   +-------------------+---------------+\n   | text/html;level=1 | 1             |\n   | text/html         | 0.7           |\n   | text/plain        | 0.3           |\n   | image/jpeg        | 0.5           |\n   | text/html;level=2 | 0.4           |\n   | text/html;level=3 | 0.7           |\n   +-------------------+---------------+\n\n   Note: A user agent might be provided with a default set of quality\n   values for certain media ranges.  However, unless the user agent is a\n   closed system that cannot interact with other rendering agents, this\n   default set ought to be configurable by the user.\n\n5.3.3.  Accept-Charset\n\n   The \"Accept-Charset\" header field can be sent by a user agent to\n   indicate what charsets are acceptable in textual response content.\n   This field allows user agents capable of understanding more\n   comprehensive or special-purpose charsets to signal that capability\n   to an origin server that is capable of representing information in\n   those charsets.\n\n     Accept-Charset = 1#( ( charset / \"*\" ) [ weight ] )\n\n   Charset names are defined in Section 3.1.1.2.  A user agent MAY\n   associate a quality value with each charset to indicate the user's\n   relative preference for that charset, as defined in Section 5.3.1.\n   An example is\n\n     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\n   The special value \"*\", if present in the Accept-Charset field,\n   matches every charset that is not mentioned elsewhere in the\n   Accept-Charset field.  If no \"*\" is present in an Accept-Charset\n   field, then any charsets not explicitly mentioned in the field are\n   considered \"not acceptable\" to the client.\n\n   A request without any Accept-Charset header field implies that the\n   user agent will accept any charset in response.  Most general-purpose\n   user agents do not send Accept-Charset, unless specifically\n\n\n\nFielding & Reschke           Standards Track                   [Page 40]\n"}],"position":{"start":{"line":2368,"column":1,"offset":99902},"end":{"line":2425,"column":4,"offset":102150}}}],"position":{"start":{"line":2368,"column":1,"offset":99902},"end":{"line":2425,"column":4,"offset":102150}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2427,"column":1,"offset":102152},"end":{"line":2427,"column":4,"offset":102155}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   configured to do so, because a detailed list of supported charsets\n   makes it easier for a server to identify an individual by virtue of\n   the user agent's request characteristics (Section 9.7).\n\n   If an Accept-Charset header field is present in a request and none of\n   the available representations for the response has a charset that is\n   listed as acceptable, the origin server can either honor the header\n   field, by sending a 406 (Not Acceptable) response, or disregard the\n   header field by treating the resource as if it is not subject to\n   content negotiation.\n\n5.3.4.  Accept-Encoding\n\n   The \"Accept-Encoding\" header field can be used by user agents to\n   indicate what response content-codings (Section 3.1.2.1) are\n   acceptable in the response.  An \"identity\" token is used as a synonym\n   for \"no encoding\" in order to communicate when no encoding is\n   preferred.\n\n     Accept-Encoding  = #( codings [ weight ] )\n     codings          = content-coding / \"identity\" / \"*\"\n\n   Each codings value MAY be given an associated quality value\n   representing the preference for that encoding, as defined in\n   Section 5.3.1.  The asterisk \"*\" symbol in an Accept-Encoding field\n   matches any available content-coding not explicitly listed in the\n   header field.\n\n   For example,\n\n     Accept-Encoding: compress, gzip\n     Accept-Encoding:\n     Accept-Encoding: *\n     Accept-Encoding: compress;q=0.5, gzip;q=1.0\n     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n\n   A request without an Accept-Encoding header field implies that the\n   user agent has no preferences regarding content-codings.  Although\n   this allows the server to use any content-coding in a response, it\n   does not imply that the user agent will be able to correctly process\n   all encodings.\n\n   A server tests whether a content-coding for a given representation is\n   acceptable using these rules:\n\n   1.  If no Accept-Encoding field is in the request, any content-coding\n       is considered acceptable by the user agent.\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 41]\n"}],"position":{"start":{"line":2429,"column":1,"offset":102157},"end":{"line":2486,"column":4,"offset":104339}}}],"position":{"start":{"line":2429,"column":1,"offset":102157},"end":{"line":2486,"column":4,"offset":104339}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2488,"column":1,"offset":104341},"end":{"line":2488,"column":4,"offset":104344}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   2.  If the representation has no content-coding, then it is\n       acceptable by default unless specifically excluded by the\n       Accept-Encoding field stating either \"identity;q=0\" or \"*;q=0\"\n       without a more specific entry for \"identity\".\n\n   3.  If the representation's content-coding is one of the\n       content-codings listed in the Accept-Encoding field, then it is\n       acceptable unless it is accompanied by a qvalue of 0.  (As\n       defined in Section 5.3.1, a qvalue of 0 means \"not acceptable\".)\n\n   4.  If multiple content-codings are acceptable, then the acceptable\n       content-coding with the highest non-zero qvalue is preferred.\n\n   An Accept-Encoding header field with a combined field-value that is\n   empty implies that the user agent does not want any content-coding in\n   response.  If an Accept-Encoding header field is present in a request\n   and none of the available representations for the response have a\n   content-coding that is listed as acceptable, the origin server SHOULD\n   send a response without any content-coding.\n\n      Note: Most HTTP/1.0 applications do not recognize or obey qvalues\n      associated with content-codings.  This means that qvalues might\n      not work and are not permitted with x-gzip or x-compress.\n\n5.3.5.  Accept-Language\n\n   The \"Accept-Language\" header field can be used by user agents to\n   indicate the set of natural languages that are preferred in the\n   response.  Language tags are defined in Section 3.1.3.1.\n\n     Accept-Language = 1#( language-range [ weight ] )\n     language-range  =\n               <language-range, see [RFC4647], SectionÂ 2.1>\n\n   Each language-range can be given an associated quality value\n   representing an estimate of the user's preference for the languages\n   specified by that range, as defined in Section 5.3.1.  For example,\n\n     Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n   would mean: \"I prefer Danish, but will accept British English and\n   other types of English\".\n\n   A request without any Accept-Language header field implies that the\n   user agent will accept any language in response.  If the header field\n   is present in a request and none of the available representations for\n   the response have a matching language tag, the origin server can\n   either disregard the header field by treating the response as if it\n\n\n\nFielding & Reschke           Standards Track                   [Page 42]\n"}],"position":{"start":{"line":2490,"column":1,"offset":104346},"end":{"line":2547,"column":4,"offset":106852}}}],"position":{"start":{"line":2490,"column":1,"offset":104346},"end":{"line":2547,"column":4,"offset":106852}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2549,"column":1,"offset":106854},"end":{"line":2549,"column":4,"offset":106857}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   is not subject to content negotiation or honor the header field by\n   sending a 406 (Not Acceptable) response.  However, the latter is not\n   encouraged, as doing so can prevent users from accessing content that\n   they might be able to use (with translation software, for example).\n\n   Note that some recipients treat the order in which language tags are\n   listed as an indication of descending priority, particularly for tags\n   that are assigned equal quality values (no value is the same as q=1).\n   However, this behavior cannot be relied upon.  For consistency and to\n   maximize interoperability, many user agents assign each language tag\n   a unique quality value while also listing them in order of decreasing\n   quality.  Additional discussion of language priority lists can be\n   found in SectionÂ 2.3 of [RFC4647].\n\n   For matching, SectionÂ 3 of [RFC4647] defines several matching\n   schemes.  Implementations can offer the most appropriate matching\n   scheme for their requirements.  The \"Basic Filtering\" scheme\n   ([RFC4647], SectionÂ 3.3.1) is identical to the matching scheme that\n   was previously defined for HTTP in SectionÂ 14.4 of [RFC2616].\n\n   It might be contrary to the privacy expectations of the user to send\n   an Accept-Language header field with the complete linguistic\n   preferences of the user in every request (Section 9.7).\n\n   Since intelligibility is highly dependent on the individual user,\n   user agents need to allow user control over the linguistic preference\n   (either through configuration of the user agent itself or by\n   defaulting to a user controllable system setting).  A user agent that\n   does not provide such control to the user MUST NOT send an\n   Accept-Language header field.\n\n      Note: User agents ought to provide guidance to users when setting\n      a preference, since users are rarely familiar with the details of\n      language matching as described above.  For example, users might\n      assume that on selecting \"en-gb\", they will be served any kind of\n      English document if British English is not available.  A user\n      agent might suggest, in such a case, to add \"en\" to the list for\n      better matching behavior.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 43]\n"}],"position":{"start":{"line":2551,"column":1,"offset":106859},"end":{"line":2608,"column":4,"offset":109222}}}],"position":{"start":{"line":2551,"column":1,"offset":106859},"end":{"line":2608,"column":4,"offset":109222}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2610,"column":1,"offset":109224},"end":{"line":2610,"column":4,"offset":109227}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n5.4.  Authentication Credentials\n\n   Two header fields are used for carrying authentication credentials,\n   as defined in [RFC7235].  Note that various custom mechanisms for\n   user authentication use the Cookie header field for this purpose, as\n   defined in [RFC6265].\n\n   +---------------------+--------------------------+\n   | Header Field Name   | Defined in...            |\n   +---------------------+--------------------------+\n   | Authorization       | SectionÂ 4.2 of [RFC7235] |\n   | Proxy-Authorization | SectionÂ 4.4 of [RFC7235] |\n   +---------------------+--------------------------+\n\n5.5.  Request Context\n\n   The following request header fields provide additional information\n   about the request context, including information about the user, user\n   agent, and resource behind the request.\n\n   +-------------------+---------------+\n   | Header Field Name | Defined in... |\n   +-------------------+---------------+\n   | From              | Section 5.5.1 |\n   | Referer           | Section 5.5.2 |\n   | User-Agent        | Section 5.5.3 |\n   +-------------------+---------------+\n\n5.5.1.  From\n\n   The \"From\" header field contains an Internet email address for a\n   human user who controls the requesting user agent.  The address ought\n   to be machine-usable, as defined by \"mailbox\" in SectionÂ 3.4 of\n   [RFC5322]:\n\n     From    = mailbox\n\n     mailbox = <mailbox, see [RFC5322], SectionÂ 3.4>\n\n   An example is:\n\n     From: webmaster@example.org\n\n   The From header field is rarely sent by non-robotic user agents.  A\n   user agent SHOULD NOT send a From header field without explicit\n   configuration by the user, since that might conflict with the user's\n   privacy interests or their site's security policy.\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 44]\n"}],"position":{"start":{"line":2612,"column":1,"offset":109229},"end":{"line":2669,"column":4,"offset":111116}}}],"position":{"start":{"line":2612,"column":1,"offset":109229},"end":{"line":2669,"column":4,"offset":111116}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2671,"column":1,"offset":111118},"end":{"line":2671,"column":4,"offset":111121}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   A robotic user agent SHOULD send a valid From header field so that\n   the person responsible for running the robot can be contacted if\n   problems occur on servers, such as if the robot is sending excessive,\n   unwanted, or invalid requests.\n\n   A server SHOULD NOT use the From header field for access control or\n   authentication, since most recipients will assume that the field\n   value is public information.\n\n5.5.2.  Referer\n\n   The \"Referer\" [sic] header field allows the user agent to specify a\n   URI reference for the resource from which the target URI was obtained\n   (i.e., the \"referrer\", though the field name is misspelled).  A user\n   agent MUST NOT include the fragment and userinfo components of the\n   URI reference [RFC3986], if any, when generating the Referer field\n   value.\n\n     Referer = absolute-URI / partial-URI\n\n   The Referer header field allows servers to generate back-links to\n   other resources for simple analytics, logging, optimized caching,\n   etc.  It also allows obsolete or mistyped links to be found for\n   maintenance.  Some servers use the Referer header field as a means of\n   denying links from other sites (so-called \"deep linking\") or\n   restricting cross-site request forgery (CSRF), but not all requests\n   contain it.\n\n   Example:\n\n     Referer: http://www.example.org/hypertext/Overview.html\n\n   If the target URI was obtained from a source that does not have its\n   own URI (e.g., input from the user keyboard, or an entry within the\n   user's bookmarks/favorites), the user agent MUST either exclude the\n   Referer field or send it with a value of \"about:blank\".\n\n   The Referer field has the potential to reveal information about the\n   request context or browsing history of the user, which is a privacy\n   concern if the referring resource's identifier reveals personal\n   information (such as an account name) or a resource that is supposed\n   to be confidential (such as behind a firewall or internal to a\n   secured service).  Most general-purpose user agents do not send the\n   Referer header field when the referring resource is a local \"file\" or\n   \"data\" URI.  A user agent MUST NOT send a Referer header field in an\n   unsecured HTTP request if the referring page was received with a\n   secure protocol.  See Section 9.4 for additional security\n   considerations.\n\n\n\nFielding & Reschke           Standards Track                   [Page 45]\n"}],"position":{"start":{"line":2673,"column":1,"offset":111123},"end":{"line":2730,"column":4,"offset":113615}}}],"position":{"start":{"line":2673,"column":1,"offset":111123},"end":{"line":2730,"column":4,"offset":113615}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2732,"column":1,"offset":113617},"end":{"line":2732,"column":4,"offset":113620}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Some intermediaries have been known to indiscriminately remove\n   Referer header fields from outgoing requests.  This has the\n   unfortunate side effect of interfering with protection against CSRF\n   attacks, which can be far more harmful to their users.\n   Intermediaries and user agent extensions that wish to limit\n   information disclosure in Referer ought to restrict their changes to\n   specific edits, such as replacing internal domain names with\n   pseudonyms or truncating the query and/or path components.  An\n   intermediary SHOULD NOT modify or delete the Referer header field\n   when the field value shares the same scheme and host as the request\n   target.\n\n5.5.3.  User-Agent\n\n   The \"User-Agent\" header field contains information about the user\n   agent originating the request, which is often used by servers to help\n   identify the scope of reported interoperability problems, to work\n   around or tailor responses to avoid particular user agent\n   limitations, and for analytics regarding browser or operating system\n   use.  A user agent SHOULD send a User-Agent field in each request\n   unless specifically configured not to do so.\n\n     User-Agent = product *( RWS ( product / comment ) )\n\n   The User-Agent field-value consists of one or more product\n   identifiers, each followed by zero or more comments (SectionÂ 3.2 of\n   [RFC7230]), which together identify the user agent software and its\n   significant subproducts.  By convention, the product identifiers are\n   listed in decreasing order of their significance for identifying the\n   user agent software.  Each product identifier consists of a name and\n   optional version.\n\n     product         = token [\"/\" product-version]\n     product-version = token\n\n   A sender SHOULD limit generated product identifiers to what is\n   necessary to identify the product; a sender MUST NOT generate\n   advertising or other nonessential information within the product\n   identifier.  A sender SHOULD NOT generate information in\n   product-version that is not a version identifier (i.e., successive\n   versions of the same product name ought to differ only in the\n   product-version portion of the product identifier).\n\n   Example:\n\n     User-Agent: CERN-LineMode/2.15 libwww/2.17b3\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 46]\n"}],"position":{"start":{"line":2734,"column":1,"offset":113622},"end":{"line":2791,"column":4,"offset":116034}}}],"position":{"start":{"line":2734,"column":1,"offset":113622},"end":{"line":2791,"column":4,"offset":116034}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2793,"column":1,"offset":116036},"end":{"line":2793,"column":4,"offset":116039}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   A user agent SHOULD NOT generate a User-Agent field containing\n   needlessly fine-grained detail and SHOULD limit the addition of\n   subproducts by third parties.  Overly long and detailed User-Agent\n   field values increase request latency and the risk of a user being\n   identified against their wishes (\"fingerprinting\").\n\n   Likewise, implementations are encouraged not to use the product\n   tokens of other implementations in order to declare compatibility\n   with them, as this circumvents the purpose of the field.  If a user\n   agent masquerades as a different user agent, recipients can assume\n   that the user intentionally desires to see responses tailored for\n   that identified user agent, even if they might not work as well for\n   the actual user agent being used.\n\n6.  Response Status Codes\n\n   The status-code element is a three-digit integer code giving the\n   result of the attempt to understand and satisfy the request.\n\n   HTTP status codes are extensible.  HTTP clients are not required to\n   understand the meaning of all registered status codes, though such\n   understanding is obviously desirable.  However, a client MUST\n   understand the class of any status code, as indicated by the first\n   digit, and treat an unrecognized status code as being equivalent to\n   the x00 status code of that class, with the exception that a\n   recipient MUST NOT cache a response with an unrecognized status code.\n\n   For example, if an unrecognized status code of 471 is received by a\n   client, the client can assume that there was something wrong with its\n   request and treat the response as if it had received a 400 (Bad\n   Request) status code.  The response message will usually contain a\n   representation that explains the status.\n\n   The first digit of the status-code defines the class of response.\n   The last two digits do not have any categorization role.  There are\n   five values for the first digit:\n\n   o  1xx (Informational): The request was received, continuing process\n\n   o  2xx (Successful): The request was successfully received,\n      understood, and accepted\n\n   o  3xx (Redirection): Further action needs to be taken in order to\n      complete the request\n\n   o  4xx (Client Error): The request contains bad syntax or cannot be\n      fulfilled\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 47]\n"}],"position":{"start":{"line":2795,"column":1,"offset":116041},"end":{"line":2852,"column":4,"offset":118486}}}],"position":{"start":{"line":2795,"column":1,"offset":116041},"end":{"line":2852,"column":4,"offset":118486}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2854,"column":1,"offset":118488},"end":{"line":2854,"column":4,"offset":118491}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   o  5xx (Server Error): The server failed to fulfill an apparently\n      valid request\n\n6.1.  Overview of Status Codes\n\n   The status codes listed below are defined in this specification,\n   SectionÂ 4 of [RFC7232], SectionÂ 4 of [RFC7233], and SectionÂ 3 of\n   [RFC7235].  The reason phrases listed here are only recommendations\n   -- they can be replaced by local equivalents without affecting the\n   protocol.\n\n   Responses with status codes that are defined as cacheable by default\n   (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in\n   this specification) can be reused by a cache with heuristic\n   expiration unless otherwise indicated by the method definition or\n   explicit cache controls [RFC7234]; all other status codes are not\n   cacheable by default.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 48]\n"}],"position":{"start":{"line":2856,"column":1,"offset":118493},"end":{"line":2913,"column":4,"offset":119465}}}],"position":{"start":{"line":2856,"column":1,"offset":118493},"end":{"line":2913,"column":4,"offset":119465}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2915,"column":1,"offset":119467},"end":{"line":2915,"column":4,"offset":119470}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   +------+-------------------------------+--------------------------+\n   | Code | Reason-Phrase                 | Defined in...            |\n   +------+-------------------------------+--------------------------+\n   | 100  | Continue                      | Section 6.2.1            |\n   | 101  | Switching Protocols           | Section 6.2.2            |\n   | 200  | OK                            | Section 6.3.1            |\n   | 201  | Created                       | Section 6.3.2            |\n   | 202  | Accepted                      | Section 6.3.3            |\n   | 203  | Non-Authoritative Information | Section 6.3.4            |\n   | 204  | No Content                    | Section 6.3.5            |\n   | 205  | Reset Content                 | Section 6.3.6            |\n   | 206  | Partial Content               | SectionÂ 4.1 of [RFC7233] |\n   | 300  | Multiple Choices              | Section 6.4.1            |\n   | 301  | Moved Permanently             | Section 6.4.2            |\n   | 302  | Found                         | Section 6.4.3            |\n   | 303  | See Other                     | Section 6.4.4            |\n   | 304  | Not Modified                  | SectionÂ 4.1 of [RFC7232] |\n   | 305  | Use Proxy                     | Section 6.4.5            |\n   | 307  | Temporary Redirect            | Section 6.4.7            |\n   | 400  | Bad Request                   | Section 6.5.1            |\n   | 401  | Unauthorized                  | SectionÂ 3.1 of [RFC7235] |\n   | 402  | Payment Required              | Section 6.5.2            |\n   | 403  | Forbidden                     | Section 6.5.3            |\n   | 404  | Not Found                     | Section 6.5.4            |\n   | 405  | Method Not Allowed            | Section 6.5.5            |\n   | 406  | Not Acceptable                | Section 6.5.6            |\n   | 407  | Proxy Authentication Required | SectionÂ 3.2 of [RFC7235] |\n   | 408  | Request Timeout               | Section 6.5.7            |\n   | 409  | Conflict                      | Section 6.5.8            |\n   | 410  | Gone                          | Section 6.5.9            |\n   | 411  | Length Required               | Section 6.5.10           |\n   | 412  | Precondition Failed           | SectionÂ 4.2 of [RFC7232] |\n   | 413  | Payload Too Large             | Section 6.5.11           |\n   | 414  | URI Too Long                  | Section 6.5.12           |\n   | 415  | Unsupported Media Type        | Section 6.5.13           |\n   | 416  | Range Not Satisfiable         | SectionÂ 4.4 of [RFC7233] |\n   | 417  | Expectation Failed            | Section 6.5.14           |\n   | 426  | Upgrade Required              | Section 6.5.15           |\n   | 500  | Internal Server Error         | Section 6.6.1            |\n   | 501  | Not Implemented               | Section 6.6.2            |\n   | 502  | Bad Gateway                   | Section 6.6.3            |\n   | 503  | Service Unavailable           | Section 6.6.4            |\n   | 504  | Gateway Timeout               | Section 6.6.5            |\n   | 505  | HTTP Version Not Supported    | Section 6.6.6            |\n   +------+-------------------------------+--------------------------+\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 49]\n"}],"position":{"start":{"line":2917,"column":1,"offset":119472},"end":{"line":2974,"column":4,"offset":122829}}}],"position":{"start":{"line":2917,"column":1,"offset":119472},"end":{"line":2974,"column":4,"offset":122829}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":2976,"column":1,"offset":122831},"end":{"line":2976,"column":4,"offset":122834}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Note that this list is not exhaustive -- it does not include\n   extension status codes defined in other specifications.  The complete\n   list of status codes is maintained by IANA.  See Section 8.2 for\n   details.\n\n6.2.  Informational 1xx\n\n   The 1xx (Informational) class of status code indicates an interim\n   response for communicating connection status or request progress\n   prior to completing the requested action and sending a final\n   response. 1xx responses are terminated by the first empty line after\n   the status-line (the empty line signaling the end of the header\n   section).  Since HTTP/1.0 did not define any 1xx status codes, a\n   server MUST NOT send a 1xx response to an HTTP/1.0 client.\n\n   A client MUST be able to parse one or more 1xx responses received\n   prior to a final response, even if the client does not expect one.  A\n   user agent MAY ignore unexpected 1xx responses.\n\n   A proxy MUST forward 1xx responses unless the proxy itself requested\n   the generation of the 1xx response.  For example, if a proxy adds an\n   \"Expect: 100-continue\" field when it forwards a request, then it need\n   not forward the corresponding 100 (Continue) response(s).\n\n6.2.1.  100 Continue\n\n   The 100 (Continue) status code indicates that the initial part of a\n   request has been received and has not yet been rejected by the\n   server.  The server intends to send a final response after the\n   request has been fully received and acted upon.\n\n   When the request contains an Expect header field that includes a\n   100-continue expectation, the 100 response indicates that the server\n   wishes to receive the request payload body, as described in\n   Section 5.1.1.  The client ought to continue sending the request and\n   discard the 100 response.\n\n   If the request did not contain an Expect header field containing the\n   100-continue expectation, the client can simply discard this interim\n   response.\n\n6.2.2.  101 Switching Protocols\n\n   The 101 (Switching Protocols) status code indicates that the server\n   understands and is willing to comply with the client's request, via\n   the Upgrade header field (SectionÂ 6.7 of [RFC7230]), for a change in\n   the application protocol being used on this connection.  The server\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 50]\n"}],"position":{"start":{"line":2978,"column":1,"offset":122836},"end":{"line":3035,"column":4,"offset":125241}}}],"position":{"start":{"line":2978,"column":1,"offset":122836},"end":{"line":3035,"column":4,"offset":125241}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3037,"column":1,"offset":125243},"end":{"line":3037,"column":4,"offset":125246}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   MUST generate an Upgrade header field in the response that indicates\n   which protocol(s) will be switched to immediately after the empty\n   line that terminates the 101 response.\n\n   It is assumed that the server will only agree to switch protocols\n   when it is advantageous to do so.  For example, switching to a newer\n   version of HTTP might be advantageous over older versions, and\n   switching to a real-time, synchronous protocol might be advantageous\n   when delivering resources that use such features.\n\n6.3.  Successful 2xx\n\n   The 2xx (Successful) class of status code indicates that the client's\n   request was successfully received, understood, and accepted.\n\n6.3.1.  200 OK\n\n   The 200 (OK) status code indicates that the request has succeeded.\n   The payload sent in a 200 response depends on the request method.\n   For the methods defined by this specification, the intended meaning\n   of the payload can be summarized as:\n\n   GET  a representation of the target resource;\n\n   HEAD  the same representation as GET, but without the representation\n      data;\n\n   POST  a representation of the status of, or results obtained from,\n      the action;\n\n   PUT, DELETE  a representation of the status of the action;\n\n   OPTIONS  a representation of the communications options;\n\n   TRACE  a representation of the request message as received by the end\n      server.\n\n   Aside from responses to CONNECT, a 200 response always has a payload,\n   though an origin server MAY generate a payload body of zero length.\n   If no payload is desired, an origin server ought to send 204 (No\n   Content) instead.  For CONNECT, no payload is allowed because the\n   successful result is a tunnel, which begins immediately after the 200\n   response header section.\n\n   A 200 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 51]\n"}],"position":{"start":{"line":3039,"column":1,"offset":125248},"end":{"line":3096,"column":4,"offset":127339}}}],"position":{"start":{"line":3039,"column":1,"offset":125248},"end":{"line":3096,"column":4,"offset":127339}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3098,"column":1,"offset":127341},"end":{"line":3098,"column":4,"offset":127344}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n6.3.2.  201 Created\n\n   The 201 (Created) status code indicates that the request has been\n   fulfilled and has resulted in one or more new resources being\n   created.  The primary resource created by the request is identified\n   by either a Location header field in the response or, if no Location\n   field is received, by the effective request URI.\n\n   The 201 response payload typically describes and links to the\n   resource(s) created.  See Section 7.2 for a discussion of the meaning\n   and purpose of validator header fields, such as ETag and\n   Last-Modified, in a 201 response.\n\n6.3.3.  202 Accepted\n\n   The 202 (Accepted) status code indicates that the request has been\n   accepted for processing, but the processing has not been completed.\n   The request might or might not eventually be acted upon, as it might\n   be disallowed when processing actually takes place.  There is no\n   facility in HTTP for re-sending a status code from an asynchronous\n   operation.\n\n   The 202 response is intentionally noncommittal.  Its purpose is to\n   allow a server to accept a request for some other process (perhaps a\n   batch-oriented process that is only run once per day) without\n   requiring that the user agent's connection to the server persist\n   until the process is completed.  The representation sent with this\n   response ought to describe the request's current status and point to\n   (or embed) a status monitor that can provide the user with an\n   estimate of when the request will be fulfilled.\n\n6.3.4.  203 Non-Authoritative Information\n\n   The 203 (Non-Authoritative Information) status code indicates that\n   the request was successful but the enclosed payload has been modified\n   from that of the origin server's 200 (OK) response by a transforming\n   proxy (SectionÂ 5.7.2 of [RFC7230]).  This status code allows the\n   proxy to notify recipients when a transformation has been applied,\n   since that knowledge might impact later decisions regarding the\n   content.  For example, future cache validation requests for the\n   content might only be applicable along the same request path (through\n   the same proxies).\n\n   The 203 response is similar to the Warning code of 214 Transformation\n   Applied (SectionÂ 5.5 of [RFC7234]), which has the advantage of being\n   applicable to responses with any status code.\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 52]\n"}],"position":{"start":{"line":3100,"column":1,"offset":127346},"end":{"line":3157,"column":4,"offset":129836}}}],"position":{"start":{"line":3100,"column":1,"offset":127346},"end":{"line":3157,"column":4,"offset":129836}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3159,"column":1,"offset":129838},"end":{"line":3159,"column":4,"offset":129841}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   A 203 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n6.3.5.  204 No Content\n\n   The 204 (No Content) status code indicates that the server has\n   successfully fulfilled the request and that there is no additional\n   content to send in the response payload body.  Metadata in the\n   response header fields refer to the target resource and its selected\n   representation after the requested action was applied.\n\n   For example, if a 204 status code is received in response to a PUT\n   request and the response contains an ETag header field, then the PUT\n   was successful and the ETag field-value contains the entity-tag for\n   the new representation of that target resource.\n\n   The 204 response allows a server to indicate that the action has been\n   successfully applied to the target resource, while implying that the\n   user agent does not need to traverse away from its current \"document\n   view\" (if any).  The server assumes that the user agent will provide\n   some indication of the success to its user, in accord with its own\n   interface, and apply any new or updated metadata in the response to\n   its active representation.\n\n   For example, a 204 status code is commonly used with document editing\n   interfaces corresponding to a \"save\" action, such that the document\n   being saved remains available to the user for editing.  It is also\n   frequently used with interfaces that expect automated data transfers\n   to be prevalent, such as within distributed version control systems.\n\n   A 204 response is terminated by the first empty line after the header\n   fields because it cannot contain a message body.\n\n   A 204 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n6.3.6.  205 Reset Content\n\n   The 205 (Reset Content) status code indicates that the server has\n   fulfilled the request and desires that the user agent reset the\n   \"document view\", which caused the request to be sent, to its original\n   state as received from the origin server.\n\n   This response is intended to support a common data entry use case\n   where the user receives content that supports data entry (a form,\n   notepad, canvas, etc.), enters or manipulates data in that space,\n\n\n\nFielding & Reschke           Standards Track                   [Page 53]\n"}],"position":{"start":{"line":3161,"column":1,"offset":129843},"end":{"line":3218,"column":4,"offset":132397}}}],"position":{"start":{"line":3161,"column":1,"offset":129843},"end":{"line":3218,"column":4,"offset":132397}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3220,"column":1,"offset":132399},"end":{"line":3220,"column":4,"offset":132402}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   causes the entered data to be submitted in a request, and then the\n   data entry mechanism is reset for the next entry so that the user can\n   easily initiate another input action.\n\n   Since the 205 status code implies that no additional content will be\n   provided, a server MUST NOT generate a payload in a 205 response.  In\n   other words, a server MUST do one of the following for a 205\n   response: a) indicate a zero-length body for the response by\n   including a Content-Length header field with a value of 0; b)\n   indicate a zero-length payload for the response by including a\n   Transfer-Encoding header field with a value of chunked and a message\n   body consisting of a single chunk of zero-length; or, c) close the\n   connection immediately after sending the blank line terminating the\n   header section.\n\n6.4.  Redirection 3xx\n\n   The 3xx (Redirection) class of status code indicates that further\n   action needs to be taken by the user agent in order to fulfill the\n   request.  If a Location header field (Section 7.1.2) is provided, the\n   user agent MAY automatically redirect its request to the URI\n   referenced by the Location field value, even if the specific status\n   code is not understood.  Automatic redirection needs to done with\n   care for methods not known to be safe, as defined in Section 4.2.1,\n   since the user might not wish to redirect an unsafe request.\n\n   There are several types of redirects:\n\n   1.  Redirects that indicate the resource might be available at a\n       different URI, as provided by the Location field, as in the\n       status codes 301 (Moved Permanently), 302 (Found), and 307\n       (Temporary Redirect).\n\n   2.  Redirection that offers a choice of matching resources, each\n       capable of representing the original request target, as in the\n       300 (Multiple Choices) status code.\n\n   3.  Redirection to a different resource, identified by the Location\n       field, that can represent an indirect response to the request, as\n       in the 303 (See Other) status code.\n\n   4.  Redirection to a previously cached result, as in the 304 (Not\n       Modified) status code.\n\n      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and\n      302 (Found) were defined for the first type of redirect\n      ([RFC1945], SectionÂ 9.3).  Early user agents split on whether the\n      method applied to the redirect target would be the same as the\n\n\n\nFielding & Reschke           Standards Track                   [Page 54]\n"}],"position":{"start":{"line":3222,"column":1,"offset":132404},"end":{"line":3279,"column":4,"offset":134976}}}],"position":{"start":{"line":3222,"column":1,"offset":132404},"end":{"line":3279,"column":4,"offset":134976}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3281,"column":1,"offset":134978},"end":{"line":3281,"column":4,"offset":134981}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n      original request or would be rewritten as GET.  Although HTTP\n      originally defined the former semantics for 301 and 302 (to match\n      its original implementation at CERN), and defined 303 (See Other)\n      to match the latter semantics, prevailing practice gradually\n      converged on the latter semantics for 301 and 302 as well.  The\n      first revision of HTTP/1.1 added 307 (Temporary Redirect) to\n      indicate the former semantics without being impacted by divergent\n      practice.  Over 10 years later, most user agents still do method\n      rewriting for 301 and 302; therefore, this specification makes\n      that behavior conformant when the original request is POST.\n\n   A client SHOULD detect and intervene in cyclical redirections (i.e.,\n   \"infinite\" redirection loops).\n\n      Note: An earlier version of this specification recommended a\n      maximum of five redirections ([RFC2068], SectionÂ 10.3).  Content\n      developers need to be aware that some clients might implement such\n      a fixed limitation.\n\n6.4.1.  300 Multiple Choices\n\n   The 300 (Multiple Choices) status code indicates that the target\n   resource has more than one representation, each with its own more\n   specific identifier, and information about the alternatives is being\n   provided so that the user (or user agent) can select a preferred\n   representation by redirecting its request to one or more of those\n   identifiers.  In other words, the server desires that the user agent\n   engage in reactive negotiation to select the most appropriate\n   representation(s) for its needs (Section 3.4).\n\n   If the server has a preferred choice, the server SHOULD generate a\n   Location header field containing a preferred choice's URI reference.\n   The user agent MAY use the Location field value for automatic\n   redirection.\n\n   For request methods other than HEAD, the server SHOULD generate a\n   payload in the 300 response containing a list of representation\n   metadata and URI reference(s) from which the user or user agent can\n   choose the one most preferred.  The user agent MAY make a selection\n   from that list automatically if it understands the provided media\n   type.  A specific format for automatic selection is not defined by\n   this specification because HTTP tries to remain orthogonal to the\n   definition of its payloads.  In practice, the representation is\n   provided in some easily parsed format believed to be acceptable to\n   the user agent, as determined by shared design or content\n   negotiation, or in some commonly accepted hypertext format.\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 55]\n"}],"position":{"start":{"line":3283,"column":1,"offset":134983},"end":{"line":3340,"column":4,"offset":137719}}}],"position":{"start":{"line":3283,"column":1,"offset":134983},"end":{"line":3340,"column":4,"offset":137719}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3342,"column":1,"offset":137721},"end":{"line":3342,"column":4,"offset":137724}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   A 300 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n      Note: The original proposal for the 300 status code defined the\n      URI header field as providing a list of alternative\n      representations, such that it would be usable for 200, 300, and\n      406 responses and be transferred in responses to the HEAD method.\n      However, lack of deployment and disagreement over syntax led to\n      both URI and Alternates (a subsequent proposal) being dropped from\n      this specification.  It is possible to communicate the list using\n      a set of Link header fields [RFC5988], each with a relationship of\n      \"alternate\", though deployment is a chicken-and-egg problem.\n\n6.4.2.  301 Moved Permanently\n\n   The 301 (Moved Permanently) status code indicates that the target\n   resource has been assigned a new permanent URI and any future\n   references to this resource ought to use one of the enclosed URIs.\n   Clients with link-editing capabilities ought to automatically re-link\n   references to the effective request URI to one or more of the new\n   references sent by the server, where possible.\n\n   The server SHOULD generate a Location header field in the response\n   containing a preferred URI reference for the new permanent URI.  The\n   user agent MAY use the Location field value for automatic\n   redirection.  The server's response payload usually contains a short\n   hypertext note with a hyperlink to the new URI(s).\n\n      Note: For historical reasons, a user agent MAY change the request\n      method from POST to GET for the subsequent request.  If this\n      behavior is undesired, the 307 (Temporary Redirect) status code\n      can be used instead.\n\n   A 301 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n6.4.3.  302 Found\n\n   The 302 (Found) status code indicates that the target resource\n   resides temporarily under a different URI.  Since the redirection\n   might be altered on occasion, the client ought to continue to use the\n   effective request URI for future requests.\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 56]\n"}],"position":{"start":{"line":3344,"column":1,"offset":137726},"end":{"line":3401,"column":4,"offset":140121}}}],"position":{"start":{"line":3344,"column":1,"offset":137726},"end":{"line":3401,"column":4,"offset":140121}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3403,"column":1,"offset":140123},"end":{"line":3403,"column":4,"offset":140126}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   The server SHOULD generate a Location header field in the response\n   containing a URI reference for the different URI.  The user agent MAY\n   use the Location field value for automatic redirection.  The server's\n   response payload usually contains a short hypertext note with a\n   hyperlink to the different URI(s).\n\n      Note: For historical reasons, a user agent MAY change the request\n      method from POST to GET for the subsequent request.  If this\n      behavior is undesired, the 307 (Temporary Redirect) status code\n      can be used instead.\n\n6.4.4.  303 See Other\n\n   The 303 (See Other) status code indicates that the server is\n   redirecting the user agent to a different resource, as indicated by a\n   URI in the Location header field, which is intended to provide an\n   indirect response to the original request.  A user agent can perform\n   a retrieval request targeting that URI (a GET or HEAD request if\n   using HTTP), which might also be redirected, and present the eventual\n   result as an answer to the original request.  Note that the new URI\n   in the Location header field is not considered equivalent to the\n   effective request URI.\n\n   This status code is applicable to any HTTP method.  It is primarily\n   used to allow the output of a POST action to redirect the user agent\n   to a selected resource, since doing so provides the information\n   corresponding to the POST response in a form that can be separately\n   identified, bookmarked, and cached, independent of the original\n   request.\n\n   A 303 response to a GET request indicates that the origin server does\n   not have a representation of the target resource that can be\n   transferred by the server over HTTP.  However, the Location field\n   value refers to a resource that is descriptive of the target\n   resource, such that making a retrieval request on that other resource\n   might result in a representation that is useful to recipients without\n   implying that it represents the original target resource.  Note that\n   answers to the questions of what can be represented, what\n   representations are adequate, and what might be a useful description\n   are outside the scope of HTTP.\n\n   Except for responses to a HEAD request, the representation of a 303\n   response ought to contain a short hypertext note with a hyperlink to\n   the same URI reference provided in the Location header field.\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 57]\n"}],"position":{"start":{"line":3405,"column":1,"offset":140128},"end":{"line":3462,"column":4,"offset":142683}}}],"position":{"start":{"line":3405,"column":1,"offset":140128},"end":{"line":3462,"column":4,"offset":142683}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3464,"column":1,"offset":142685},"end":{"line":3464,"column":4,"offset":142688}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n6.4.5.  305 Use Proxy\n\n   The 305 (Use Proxy) status code was defined in a previous version of\n   this specification and is now deprecated (Appendix B).\n\n6.4.6.  306 (Unused)\n\n   The 306 status code was defined in a previous version of this\n   specification, is no longer used, and the code is reserved.\n\n6.4.7.  307 Temporary Redirect\n\n   The 307 (Temporary Redirect) status code indicates that the target\n   resource resides temporarily under a different URI and the user agent\n   MUST NOT change the request method if it performs an automatic\n   redirection to that URI.  Since the redirection can change over time,\n   the client ought to continue using the original effective request URI\n   for future requests.\n\n   The server SHOULD generate a Location header field in the response\n   containing a URI reference for the different URI.  The user agent MAY\n   use the Location field value for automatic redirection.  The server's\n   response payload usually contains a short hypertext note with a\n   hyperlink to the different URI(s).\n\n      Note: This status code is similar to 302 (Found), except that it\n      does not allow changing the request method from POST to GET.  This\n      specification defines no equivalent counterpart for 301 (Moved\n      Permanently) ([RFC7238], however, defines the status code 308\n      (Permanent Redirect) for this purpose).\n\n6.5.  Client Error 4xx\n\n   The 4xx (Client Error) class of status code indicates that the client\n   seems to have erred.  Except when responding to a HEAD request, the\n   server SHOULD send a representation containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n   condition.  These status codes are applicable to any request method.\n   User agents SHOULD display any included representation to the user.\n\n6.5.1.  400 Bad Request\n\n   The 400 (Bad Request) status code indicates that the server cannot or\n   will not process the request due to something that is perceived to be\n   a client error (e.g., malformed request syntax, invalid request\n   message framing, or deceptive request routing).\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 58]\n"}],"position":{"start":{"line":3466,"column":1,"offset":142690},"end":{"line":3523,"column":4,"offset":144954}}}],"position":{"start":{"line":3466,"column":1,"offset":142690},"end":{"line":3523,"column":4,"offset":144954}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3525,"column":1,"offset":144956},"end":{"line":3525,"column":4,"offset":144959}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n6.5.2.  402 Payment Required\n\n   The 402 (Payment Required) status code is reserved for future use.\n\n6.5.3.  403 Forbidden\n\n   The 403 (Forbidden) status code indicates that the server understood\n   the request but refuses to authorize it.  A server that wishes to\n   make public why the request has been forbidden can describe that\n   reason in the response payload (if any).\n\n   If authentication credentials were provided in the request, the\n   server considers them insufficient to grant access.  The client\n   SHOULD NOT automatically repeat the request with the same\n   credentials.  The client MAY repeat the request with new or different\n   credentials.  However, a request might be forbidden for reasons\n   unrelated to the credentials.\n\n   An origin server that wishes to \"hide\" the current existence of a\n   forbidden target resource MAY instead respond with a status code of\n   404 (Not Found).\n\n6.5.4.  404 Not Found\n\n   The 404 (Not Found) status code indicates that the origin server did\n   not find a current representation for the target resource or is not\n   willing to disclose that one exists.  A 404 status code does not\n   indicate whether this lack of representation is temporary or\n   permanent; the 410 (Gone) status code is preferred over 404 if the\n   origin server knows, presumably through some configurable means, that\n   the condition is likely to be permanent.\n\n   A 404 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n6.5.5.  405 Method Not Allowed\n\n   The 405 (Method Not Allowed) status code indicates that the method\n   received in the request-line is known by the origin server but not\n   supported by the target resource.  The origin server MUST generate an\n   Allow header field in a 405 response containing a list of the target\n   resource's currently supported methods.\n\n   A 405 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 59]\n"}],"position":{"start":{"line":3527,"column":1,"offset":144961},"end":{"line":3584,"column":4,"offset":147213}}}],"position":{"start":{"line":3527,"column":1,"offset":144961},"end":{"line":3584,"column":4,"offset":147213}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3586,"column":1,"offset":147215},"end":{"line":3586,"column":4,"offset":147218}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n6.5.6.  406 Not Acceptable\n\n   The 406 (Not Acceptable) status code indicates that the target\n   resource does not have a current representation that would be\n   acceptable to the user agent, according to the proactive negotiation\n   header fields received in the request (Section 5.3), and the server\n   is unwilling to supply a default representation.\n\n   The server SHOULD generate a payload containing a list of available\n   representation characteristics and corresponding resource identifiers\n   from which the user or user agent can choose the one most\n   appropriate.  A user agent MAY automatically select the most\n   appropriate choice from that list.  However, this specification does\n   not define any standard for such automatic selection, as described in\n   Section 6.4.1.\n\n6.5.7.  408 Request Timeout\n\n   The 408 (Request Timeout) status code indicates that the server did\n   not receive a complete request message within the time that it was\n   prepared to wait.  A server SHOULD send the \"close\" connection option\n   (SectionÂ 6.1 of [RFC7230]) in the response, since 408 implies that\n   the server has decided to close the connection rather than continue\n   waiting.  If the client has an outstanding request in transit, the\n   client MAY repeat that request on a new connection.\n\n6.5.8.  409 Conflict\n\n   The 409 (Conflict) status code indicates that the request could not\n   be completed due to a conflict with the current state of the target\n   resource.  This code is used in situations where the user might be\n   able to resolve the conflict and resubmit the request.  The server\n   SHOULD generate a payload that includes enough information for a user\n   to recognize the source of the conflict.\n\n   Conflicts are most likely to occur in response to a PUT request.  For\n   example, if versioning were being used and the representation being\n   PUT included changes to a resource that conflict with those made by\n   an earlier (third-party) request, the origin server might use a 409\n   response to indicate that it can't complete the request.  In this\n   case, the response representation would likely contain information\n   useful for merging the differences based on the revision history.\n\n6.5.9.  410 Gone\n\n   The 410 (Gone) status code indicates that access to the target\n   resource is no longer available at the origin server and that this\n   condition is likely to be permanent.  If the origin server does not\n\n\n\nFielding & Reschke           Standards Track                   [Page 60]\n"}],"position":{"start":{"line":3588,"column":1,"offset":147220},"end":{"line":3645,"column":4,"offset":149819}}}],"position":{"start":{"line":3588,"column":1,"offset":147220},"end":{"line":3645,"column":4,"offset":149819}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3647,"column":1,"offset":149821},"end":{"line":3647,"column":4,"offset":149824}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   know, or has no facility to determine, whether or not the condition\n   is permanent, the status code 404 (Not Found) ought to be used\n   instead.\n\n   The 410 response is primarily intended to assist the task of web\n   maintenance by notifying the recipient that the resource is\n   intentionally unavailable and that the server owners desire that\n   remote links to that resource be removed.  Such an event is common\n   for limited-time, promotional services and for resources belonging to\n   individuals no longer associated with the origin server's site.  It\n   is not necessary to mark all permanently unavailable resources as\n   \"gone\" or to keep the mark for any length of time -- that is left to\n   the discretion of the server owner.\n\n   A 410 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n6.5.10.  411 Length Required\n\n   The 411 (Length Required) status code indicates that the server\n   refuses to accept the request without a defined Content-Length\n   (SectionÂ 3.3.2 of [RFC7230]).  The client MAY repeat the request if\n   it adds a valid Content-Length header field containing the length of\n   the message body in the request message.\n\n6.5.11.  413 Payload Too Large\n\n   The 413 (Payload Too Large) status code indicates that the server is\n   refusing to process a request because the request payload is larger\n   than the server is willing or able to process.  The server MAY close\n   the connection to prevent the client from continuing the request.\n\n   If the condition is temporary, the server SHOULD generate a\n   Retry-After header field to indicate that it is temporary and after\n   what time the client MAY try again.\n\n6.5.12.  414 URI Too Long\n\n   The 414 (URI Too Long) status code indicates that the server is\n   refusing to service the request because the request-target (Section\n   5.3 of [RFC7230]) is longer than the server is willing to interpret.\n   This rare condition is only likely to occur when a client has\n   improperly converted a POST request to a GET request with long query\n   information, when the client has descended into a \"black hole\" of\n   redirection (e.g., a redirected URI prefix that points to a suffix of\n   itself) or when the server is under attack by a client attempting to\n   exploit potential security holes.\n\n\n\nFielding & Reschke           Standards Track                   [Page 61]\n"}],"position":{"start":{"line":3649,"column":1,"offset":149826},"end":{"line":3706,"column":4,"offset":152365}}}],"position":{"start":{"line":3649,"column":1,"offset":149826},"end":{"line":3706,"column":4,"offset":152365}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3708,"column":1,"offset":152367},"end":{"line":3708,"column":4,"offset":152370}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   A 414 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n6.5.13.  415 Unsupported Media Type\n\n   The 415 (Unsupported Media Type) status code indicates that the\n   origin server is refusing to service the request because the payload\n   is in a format not supported by this method on the target resource.\n   The format problem might be due to the request's indicated\n   Content-Type or Content-Encoding, or as a result of inspecting the\n   data directly.\n\n6.5.14.  417 Expectation Failed\n\n   The 417 (Expectation Failed) status code indicates that the\n   expectation given in the request's Expect header field\n   (Section 5.1.1) could not be met by at least one of the inbound\n   servers.\n\n6.5.15.  426 Upgrade Required\n\n   The 426 (Upgrade Required) status code indicates that the server\n   refuses to perform the request using the current protocol but might\n   be willing to do so after the client upgrades to a different\n   protocol.  The server MUST send an Upgrade header field in a 426\n   response to indicate the required protocol(s) (SectionÂ 6.7 of\n   [RFC7230]).\n\n   Example:\n\n     HTTP/1.1 426 Upgrade Required\n     Upgrade: HTTP/3.0\n     Connection: Upgrade\n     Content-Length: 53\n     Content-Type: text/plain\n\n     This service requires use of the HTTP/3.0 protocol.\n\n6.6.  Server Error 5xx\n\n   The 5xx (Server Error) class of status code indicates that the server\n   is aware that it has erred or is incapable of performing the\n   requested method.  Except when responding to a HEAD request, the\n   server SHOULD send a representation containing an explanation of the\n   error situation, and whether it is a temporary or permanent\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 62]\n"}],"position":{"start":{"line":3710,"column":1,"offset":152372},"end":{"line":3767,"column":4,"offset":154290}}}],"position":{"start":{"line":3710,"column":1,"offset":152372},"end":{"line":3767,"column":4,"offset":154290}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3769,"column":1,"offset":154292},"end":{"line":3769,"column":4,"offset":154295}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   condition.  A user agent SHOULD display any included representation\n   to the user.  These response codes are applicable to any request\n   method.\n\n6.6.1.  500 Internal Server Error\n\n   The 500 (Internal Server Error) status code indicates that the server\n   encountered an unexpected condition that prevented it from fulfilling\n   the request.\n\n6.6.2.  501 Not Implemented\n\n   The 501 (Not Implemented) status code indicates that the server does\n   not support the functionality required to fulfill the request.  This\n   is the appropriate response when the server does not recognize the\n   request method and is not capable of supporting it for any resource.\n\n   A 501 response is cacheable by default; i.e., unless otherwise\n   indicated by the method definition or explicit cache controls (see\n   SectionÂ 4.2.2 of [RFC7234]).\n\n6.6.3.  502 Bad Gateway\n\n   The 502 (Bad Gateway) status code indicates that the server, while\n   acting as a gateway or proxy, received an invalid response from an\n   inbound server it accessed while attempting to fulfill the request.\n\n6.6.4.  503 Service Unavailable\n\n   The 503 (Service Unavailable) status code indicates that the server\n   is currently unable to handle the request due to a temporary overload\n   or scheduled maintenance, which will likely be alleviated after some\n   delay.  The server MAY send a Retry-After header field\n   (Section 7.1.3) to suggest an appropriate amount of time for the\n   client to wait before retrying the request.\n\n      Note: The existence of the 503 status code does not imply that a\n      server has to use it when becoming overloaded.  Some servers might\n      simply refuse the connection.\n\n6.6.5.  504 Gateway Timeout\n\n   The 504 (Gateway Timeout) status code indicates that the server,\n   while acting as a gateway or proxy, did not receive a timely response\n   from an upstream server it needed to access in order to complete the\n   request.\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 63]\n"}],"position":{"start":{"line":3771,"column":1,"offset":154297},"end":{"line":3828,"column":4,"offset":156387}}}],"position":{"start":{"line":3771,"column":1,"offset":154297},"end":{"line":3828,"column":4,"offset":156387}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3830,"column":1,"offset":156389},"end":{"line":3830,"column":4,"offset":156392}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n6.6.6.  505 HTTP Version Not Supported\n\n   The 505 (HTTP Version Not Supported) status code indicates that the\n   server does not support, or refuses to support, the major version of\n   HTTP that was used in the request message.  The server is indicating\n   that it is unable or unwilling to complete the request using the same\n   major version as the client, as described in SectionÂ 2.6 of\n   [RFC7230], other than with this error message.  The server SHOULD\n   generate a representation for the 505 response that describes why\n   that version is not supported and what other protocols are supported\n   by that server.\n\n7.  Response Header Fields\n\n   The response header fields allow the server to pass additional\n   information about the response beyond what is placed in the\n   status-line.  These header fields give information about the server,\n   about further access to the target resource, or about related\n   resources.\n\n   Although each response header field has a defined meaning, in\n   general, the precise semantics might be further refined by the\n   semantics of the request method and/or response status code.\n\n7.1.  Control Data\n\n   Response header fields can supply control data that supplements the\n   status code, directs caching, or instructs the client where to go\n   next.\n\n   +-------------------+--------------------------+\n   | Header Field Name | Defined in...            |\n   +-------------------+--------------------------+\n   | Age               | SectionÂ 5.1 of [RFC7234] |\n   | Cache-Control     | SectionÂ 5.2 of [RFC7234] |\n   | Expires           | SectionÂ 5.3 of [RFC7234] |\n   | Date              | Section 7.1.1.2          |\n   | Location          | Section 7.1.2            |\n   | Retry-After       | Section 7.1.3            |\n   | Vary              | Section 7.1.4            |\n   | Warning           | SectionÂ 5.5 of [RFC7234] |\n   +-------------------+--------------------------+\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 64]\n"}],"position":{"start":{"line":3832,"column":1,"offset":156394},"end":{"line":3889,"column":4,"offset":158479}}}],"position":{"start":{"line":3832,"column":1,"offset":156394},"end":{"line":3889,"column":4,"offset":158479}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3891,"column":1,"offset":158481},"end":{"line":3891,"column":4,"offset":158484}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n7.1.1.  Origination Date\n\n7.1.1.1.  Date/Time Formats\n\n   Prior to 1995, there were three different formats commonly used by\n   servers to communicate timestamps.  For compatibility with old\n   implementations, all three are defined here.  The preferred format is\n   a fixed-length and single-zone subset of the date and time\n   specification used by the Internet Message Format [RFC5322].\n\n     HTTP-date    = IMF-fixdate / obs-date\n\n   An example of the preferred format is\n\n     Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate\n\n   Examples of the two obsolete formats are\n\n     Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete RFC 850 format\n     Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format\n\n   A recipient that parses a timestamp value in an HTTP header field\n   MUST accept all three HTTP-date formats.  When a sender generates a\n   header field that contains one or more timestamps defined as\n   HTTP-date, the sender MUST generate those timestamps in the\n   IMF-fixdate format.\n\n   An HTTP-date value represents time as an instance of Coordinated\n   Universal Time (UTC).  The first two formats indicate UTC by the\n   three-letter abbreviation for Greenwich Mean Time, \"GMT\", a\n   predecessor of the UTC name; values in the asctime format are assumed\n   to be in UTC.  A sender that generates HTTP-date values from a local\n   clock ought to use NTP ([RFC5905]) or some similar protocol to\n   synchronize its clock to UTC.\n\n   Preferred format:\n\n     IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n     ; fixed length/zone/capitalization subset of the format\n     ; see SectionÂ 3.3 of [RFC5322]\n\n     day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n                  / %x54.75.65 ; \"Tue\", case-sensitive\n                  / %x57.65.64 ; \"Wed\", case-sensitive\n                  / %x54.68.75 ; \"Thu\", case-sensitive\n                  / %x46.72.69 ; \"Fri\", case-sensitive\n                  / %x53.61.74 ; \"Sat\", case-sensitive\n                  / %x53.75.6E ; \"Sun\", case-sensitive\n\n\n\nFielding & Reschke           Standards Track                   [Page 65]\n"}],"position":{"start":{"line":3893,"column":1,"offset":158486},"end":{"line":3950,"column":4,"offset":160655}}}],"position":{"start":{"line":3893,"column":1,"offset":158486},"end":{"line":3950,"column":4,"offset":160655}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":3952,"column":1,"offset":160657},"end":{"line":3952,"column":4,"offset":160660}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n     date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n     day          = 2DIGIT\n     month        = %x4A.61.6E ; \"Jan\", case-sensitive\n                  / %x46.65.62 ; \"Feb\", case-sensitive\n                  / %x4D.61.72 ; \"Mar\", case-sensitive\n                  / %x41.70.72 ; \"Apr\", case-sensitive\n                  / %x4D.61.79 ; \"May\", case-sensitive\n                  / %x4A.75.6E ; \"Jun\", case-sensitive\n                  / %x4A.75.6C ; \"Jul\", case-sensitive\n                  / %x41.75.67 ; \"Aug\", case-sensitive\n                  / %x53.65.70 ; \"Sep\", case-sensitive\n                  / %x4F.63.74 ; \"Oct\", case-sensitive\n                  / %x4E.6F.76 ; \"Nov\", case-sensitive\n                  / %x44.65.63 ; \"Dec\", case-sensitive\n     year         = 4DIGIT\n\n     GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n     time-of-day  = hour \":\" minute \":\" second\n                  ; 00:00:00 - 23:59:60 (leap second)\n\n     hour         = 2DIGIT\n     minute       = 2DIGIT\n     second       = 2DIGIT\n\n   Obsolete formats:\n\n     obs-date     = rfc850-date / asctime-date\n\n     rfc850-date  = day-name-l \",\" SP date2 SP time-of-day SP GMT\n     date2        = day \"-\" month \"-\" 2DIGIT\n                  ; e.g., 02-Jun-82\n\n     day-name-l   = %x4D.6F.6E.64.61.79    ; \"Monday\", case-sensitive\n            / %x54.75.65.73.64.61.79       ; \"Tuesday\", case-sensitive\n            / %x57.65.64.6E.65.73.64.61.79 ; \"Wednesday\", case-sensitive\n            / %x54.68.75.72.73.64.61.79    ; \"Thursday\", case-sensitive\n            / %x46.72.69.64.61.79          ; \"Friday\", case-sensitive\n            / %x53.61.74.75.72.64.61.79    ; \"Saturday\", case-sensitive\n            / %x53.75.6E.64.61.79          ; \"Sunday\", case-sensitive\n\n\n     asctime-date = day-name SP date3 SP time-of-day SP year\n     date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))\n                  ; e.g., Jun  2\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 66]\n"}],"position":{"start":{"line":3954,"column":1,"offset":160662},"end":{"line":4011,"column":4,"offset":162724}}}],"position":{"start":{"line":3954,"column":1,"offset":160662},"end":{"line":4011,"column":4,"offset":162724}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4013,"column":1,"offset":162726},"end":{"line":4013,"column":4,"offset":162729}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   HTTP-date is case sensitive.  A sender MUST NOT generate additional\n   whitespace in an HTTP-date beyond that specifically included as SP in\n   the grammar.  The semantics of day-name, day, month, year, and\n   time-of-day are the same as those defined for the Internet Message\n   Format constructs with the corresponding name ([RFC5322], Section\n   3.3).\n\n   Recipients of a timestamp value in rfc850-date format, which uses a\n   two-digit year, MUST interpret a timestamp that appears to be more\n   than 50 years in the future as representing the most recent year in\n   the past that had the same last two digits.\n\n   Recipients of timestamp values are encouraged to be robust in parsing\n   timestamps unless otherwise restricted by the field definition.  For\n   example, messages are occasionally forwarded over HTTP from a\n   non-HTTP source that might generate any of the date and time\n   specifications defined by the Internet Message Format.\n\n      Note: HTTP requirements for the date/time stamp format apply only\n      to their usage within the protocol stream.  Implementations are\n      not required to use these formats for user presentation, request\n      logging, etc.\n\n7.1.1.2.  Date\n\n   The \"Date\" header field represents the date and time at which the\n   message was originated, having the same semantics as the Origination\n   Date Field (orig-date) defined in SectionÂ 3.6.1 of [RFC5322].  The\n   field value is an HTTP-date, as defined in Section 7.1.1.1.\n\n     Date = HTTP-date\n\n   An example is\n\n     Date: Tue, 15 Nov 1994 08:12:31 GMT\n\n   When a Date header field is generated, the sender SHOULD generate its\n   field value as the best available approximation of the date and time\n   of message generation.  In theory, the date ought to represent the\n   moment just before the payload is generated.  In practice, the date\n   can be generated at any time during message origination.\n\n   An origin server MUST NOT send a Date header field if it does not\n   have a clock capable of providing a reasonable approximation of the\n   current instance in Coordinated Universal Time.  An origin server MAY\n   send a Date header field if the response is in the 1xx\n   (Informational) or 5xx (Server Error) class of status codes.  An\n   origin server MUST send a Date header field in all other cases.\n\n\n\nFielding & Reschke           Standards Track                   [Page 67]\n"}],"position":{"start":{"line":4015,"column":1,"offset":162731},"end":{"line":4072,"column":4,"offset":165203}}}],"position":{"start":{"line":4015,"column":1,"offset":162731},"end":{"line":4072,"column":4,"offset":165203}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4074,"column":1,"offset":165205},"end":{"line":4074,"column":4,"offset":165208}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   A recipient with a clock that receives a response message without a\n   Date header field MUST record the time it was received and append a\n   corresponding Date header field to the message's header section if it\n   is cached or forwarded downstream.\n\n   A user agent MAY send a Date header field in a request, though\n   generally will not do so unless it is believed to convey useful\n   information to the server.  For example, custom applications of HTTP\n   might convey a Date if the server is expected to adjust its\n   interpretation of the user's request based on differences between the\n   user agent and server clocks.\n\n7.1.2.  Location\n\n   The \"Location\" header field is used in some responses to refer to a\n   specific resource in relation to the response.  The type of\n   relationship is defined by the combination of request method and\n   status code semantics.\n\n     Location = URI-reference\n\n   The field value consists of a single URI-reference.  When it has the\n   form of a relative reference ([RFC3986], SectionÂ 4.2), the final\n   value is computed by resolving it against the effective request URI\n   ([RFC3986], SectionÂ 5).\n\n   For 201 (Created) responses, the Location value refers to the primary\n   resource created by the request.  For 3xx (Redirection) responses,\n   the Location value refers to the preferred target resource for\n   automatically redirecting the request.\n\n   If the Location value provided in a 3xx (Redirection) response does\n   not have a fragment component, a user agent MUST process the\n   redirection as if the value inherits the fragment component of the\n   URI reference used to generate the request target (i.e., the\n   redirection inherits the original reference's fragment, if any).\n\n   For example, a GET request generated for the URI reference\n   \"http://www.example.org/~tim\" might result in a 303 (See Other)\n   response containing the header field:\n\n     Location: /People.html#tim\n\n   which suggests that the user agent redirect to\n   \"http://www.example.org/People.html#tim\"\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 68]\n"}],"position":{"start":{"line":4076,"column":1,"offset":165210},"end":{"line":4133,"column":4,"offset":167406}}}],"position":{"start":{"line":4076,"column":1,"offset":165210},"end":{"line":4133,"column":4,"offset":167406}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4135,"column":1,"offset":167408},"end":{"line":4135,"column":4,"offset":167411}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Likewise, a GET request generated for the URI reference\n   \"http://www.example.org/index.html#larry\" might result in a 301\n   (Moved Permanently) response containing the header field:\n\n     Location: http://www.example.net/index.html\n\n   which suggests that the user agent redirect to\n   \"http://www.example.net/index.html#larry\", preserving the original\n   fragment identifier.\n\n   There are circumstances in which a fragment identifier in a Location\n   value would not be appropriate.  For example, the Location header\n   field in a 201 (Created) response is supposed to provide a URI that\n   is specific to the created resource.\n\n      Note: Some recipients attempt to recover from Location fields that\n      are not valid URI references.  This specification does not mandate\n      or define such processing, but does allow it for the sake of\n      robustness.\n\n      Note: The Content-Location header field (Section 3.1.4.2) differs\n      from Location in that the Content-Location refers to the most\n      specific resource corresponding to the enclosed representation.\n      It is therefore possible for a response to contain both the\n      Location and Content-Location header fields.\n\n7.1.3.  Retry-After\n\n   Servers send the \"Retry-After\" header field to indicate how long the\n   user agent ought to wait before making a follow-up request.  When\n   sent with a 503 (Service Unavailable) response, Retry-After indicates\n   how long the service is expected to be unavailable to the client.\n   When sent with any 3xx (Redirection) response, Retry-After indicates\n   the minimum time that the user agent is asked to wait before issuing\n   the redirected request.\n\n   The value of this field can be either an HTTP-date or a number of\n   seconds to delay after the response is received.\n\n     Retry-After = HTTP-date / delay-seconds\n\n   A delay-seconds value is a non-negative decimal integer, representing\n   time in seconds.\n\n     delay-seconds  = 1*DIGIT\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 69]\n"}],"position":{"start":{"line":4137,"column":1,"offset":167413},"end":{"line":4194,"column":4,"offset":169539}}}],"position":{"start":{"line":4137,"column":1,"offset":167413},"end":{"line":4194,"column":4,"offset":169539}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4196,"column":1,"offset":169541},"end":{"line":4196,"column":4,"offset":169544}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Two examples of its use are\n\n     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\n     Retry-After: 120\n\n   In the latter example, the delay is 2 minutes.\n\n7.1.4.  Vary\n\n   The \"Vary\" header field in a response describes what parts of a\n   request message, aside from the method, Host header field, and\n   request target, might influence the origin server's process for\n   selecting and representing this response.  The value consists of\n   either a single asterisk (\"*\") or a list of header field names\n   (case-insensitive).\n\n     Vary = \"*\" / 1#field-name\n\n   A Vary field value of \"*\" signals that anything about the request\n   might play a role in selecting the response representation, possibly\n   including elements outside the message syntax (e.g., the client's\n   network address).  A recipient will not be able to determine whether\n   this response is appropriate for a later request without forwarding\n   the request to the origin server.  A proxy MUST NOT generate a Vary\n   field with a \"*\" value.\n\n   A Vary field value consisting of a comma-separated list of names\n   indicates that the named request header fields, known as the\n   selecting header fields, might have a role in selecting the\n   representation.  The potential selecting header fields are not\n   limited to those defined by this specification.\n\n   For example, a response that contains\n\n     Vary: accept-encoding, accept-language\n\n   indicates that the origin server might have used the request's\n   Accept-Encoding and Accept-Language fields (or lack thereof) as\n   determining factors while choosing the content for this response.\n\n   An origin server might send Vary with a list of fields for two\n   purposes:\n\n   1.  To inform cache recipients that they MUST NOT use this response\n       to satisfy a later request unless the later request has the same\n       values for the listed fields as the original request (SectionÂ 4.1\n       of [RFC7234]).  In other words, Vary expands the cache key\n       required to match a new request to the stored cache entry.\n\n\n\nFielding & Reschke           Standards Track                   [Page 70]\n"}],"position":{"start":{"line":4198,"column":1,"offset":169546},"end":{"line":4255,"column":4,"offset":171746}}}],"position":{"start":{"line":4198,"column":1,"offset":169546},"end":{"line":4255,"column":4,"offset":171746}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4257,"column":1,"offset":171748},"end":{"line":4257,"column":4,"offset":171751}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   2.  To inform user agent recipients that this response is subject to\n       content negotiation (Section 5.3) and that a different\n       representation might be sent in a subsequent request if\n       additional parameters are provided in the listed header fields\n       (proactive negotiation).\n\n   An origin server SHOULD send a Vary header field when its algorithm\n   for selecting a representation varies based on aspects of the request\n   message other than the method and request target, unless the variance\n   cannot be crossed or the origin server has been deliberately\n   configured to prevent cache transparency.  For example, there is no\n   need to send the Authorization field name in Vary because reuse\n   across users is constrained by the field definition (SectionÂ 4.2 of\n   [RFC7235]).  Likewise, an origin server might use Cache-Control\n   directives (SectionÂ 5.2 of [RFC7234]) to supplant Vary if it\n   considers the variance less significant than the performance cost of\n   Vary's impact on caching.\n\n7.2.  Validator Header Fields\n\n   Validator header fields convey metadata about the selected\n   representation (Section 3).  In responses to safe requests, validator\n   fields describe the selected representation chosen by the origin\n   server while handling the response.  Note that, depending on the\n   status code semantics, the selected representation for a given\n   response is not necessarily the same as the representation enclosed\n   as response payload.\n\n   In a successful response to a state-changing request, validator\n   fields describe the new representation that has replaced the prior\n   selected representation as a result of processing the request.\n\n   For example, an ETag header field in a 201 (Created) response\n   communicates the entity-tag of the newly created resource's\n   representation, so that it can be used in later conditional requests\n   to prevent the \"lost update\" problem [RFC7232].\n\n   +-------------------+--------------------------+\n   | Header Field Name | Defined in...            |\n   +-------------------+--------------------------+\n   | ETag              | SectionÂ 2.3 of [RFC7232] |\n   | Last-Modified     | SectionÂ 2.2 of [RFC7232] |\n   +-------------------+--------------------------+\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 71]\n"}],"position":{"start":{"line":4259,"column":1,"offset":171753},"end":{"line":4316,"column":4,"offset":174172}}}],"position":{"start":{"line":4259,"column":1,"offset":171753},"end":{"line":4316,"column":4,"offset":174172}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4318,"column":1,"offset":174174},"end":{"line":4318,"column":4,"offset":174177}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n7.3.  Authentication Challenges\n\n   Authentication challenges indicate what mechanisms are available for\n   the client to provide authentication credentials in future requests.\n\n   +--------------------+--------------------------+\n   | Header Field Name  | Defined in...            |\n   +--------------------+--------------------------+\n   | WWW-Authenticate   | SectionÂ 4.1 of [RFC7235] |\n   | Proxy-Authenticate | SectionÂ 4.3 of [RFC7235] |\n   +--------------------+--------------------------+\n\n7.4.  Response Context\n\n   The remaining response header fields provide more information about\n   the target resource for potential use in later requests.\n\n   +-------------------+--------------------------+\n   | Header Field Name | Defined in...            |\n   +-------------------+--------------------------+\n   | Accept-Ranges     | SectionÂ 2.3 of [RFC7233] |\n   | Allow             | Section 7.4.1            |\n   | Server            | Section 7.4.2            |\n   +-------------------+--------------------------+\n\n7.4.1.  Allow\n\n   The \"Allow\" header field lists the set of methods advertised as\n   supported by the target resource.  The purpose of this field is\n   strictly to inform the recipient of valid request methods associated\n   with the resource.\n\n     Allow = #method\n\n   Example of use:\n\n     Allow: GET, HEAD, PUT\n\n   The actual set of allowed methods is defined by the origin server at\n   the time of each request.  An origin server MUST generate an Allow\n   field in a 405 (Method Not Allowed) response and MAY do so in any\n   other response.  An empty Allow field value indicates that the\n   resource allows no methods, which might occur in a 405 response if\n   the resource has been temporarily disabled by configuration.\n\n   A proxy MUST NOT modify the Allow header field -- it does not need to\n   understand all of the indicated methods in order to handle them\n   according to the generic message handling rules.\n\n\n\nFielding & Reschke           Standards Track                   [Page 72]\n"}],"position":{"start":{"line":4320,"column":1,"offset":174179},"end":{"line":4377,"column":4,"offset":176274}}}],"position":{"start":{"line":4320,"column":1,"offset":174179},"end":{"line":4377,"column":4,"offset":176274}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4379,"column":1,"offset":176276},"end":{"line":4379,"column":4,"offset":176279}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n7.4.2.  Server\n\n   The \"Server\" header field contains information about the software\n   used by the origin server to handle the request, which is often used\n   by clients to help identify the scope of reported interoperability\n   problems, to work around or tailor requests to avoid particular\n   server limitations, and for analytics regarding server or operating\n   system use.  An origin server MAY generate a Server field in its\n   responses.\n\n     Server = product *( RWS ( product / comment ) )\n\n   The Server field-value consists of one or more product identifiers,\n   each followed by zero or more comments (SectionÂ 3.2 of [RFC7230]),\n   which together identify the origin server software and its\n   significant subproducts.  By convention, the product identifiers are\n   listed in decreasing order of their significance for identifying the\n   origin server software.  Each product identifier consists of a name\n   and optional version, as defined in Section 5.5.3.\n\n   Example:\n\n     Server: CERN/3.0 libwww/2.17\n\n   An origin server SHOULD NOT generate a Server field containing\n   needlessly fine-grained detail and SHOULD limit the addition of\n   subproducts by third parties.  Overly long and detailed Server field\n   values increase response latency and potentially reveal internal\n   implementation details that might make it (slightly) easier for\n   attackers to find and exploit known security holes.\n\n8.  IANA Considerations\n\n8.1.  Method Registry\n\n   The \"Hypertext Transfer Protocol (HTTP) Method Registry\" defines the\n   namespace for the request method token (Section 4).  The method\n   registry has been created and is now maintained at\n   <http://www.iana.org/assignments/http-methods>.\n\n\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 73]\n"}],"position":{"start":{"line":4381,"column":1,"offset":176281},"end":{"line":4438,"column":4,"offset":178160}}}],"position":{"start":{"line":4381,"column":1,"offset":176281},"end":{"line":4438,"column":4,"offset":178160}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4440,"column":1,"offset":178162},"end":{"line":4440,"column":4,"offset":178165}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n8.1.1.  Procedure\n\n   HTTP method registrations MUST include the following fields:\n\n   o  Method Name (see Section 4)\n\n   o  Safe (\"yes\" or \"no\", see Section 4.2.1)\n\n   o  Idempotent (\"yes\" or \"no\", see Section 4.2.2)\n\n   o  Pointer to specification text\n\n   Values to be added to this namespace require IETF Review (see\n   [RFC5226], SectionÂ 4.1).\n\n8.1.2.  Considerations for New Methods\n\n   Standardized methods are generic; that is, they are potentially\n   applicable to any resource, not just one particular media type, kind\n   of resource, or application.  As such, it is preferred that new\n   methods be registered in a document that isn't specific to a single\n   application or data format, since orthogonal technologies deserve\n   orthogonal specification.\n\n   Since message parsing (SectionÂ 3.3 of [RFC7230]) needs to be\n   independent of method semantics (aside from responses to HEAD),\n   definitions of new methods cannot change the parsing algorithm or\n   prohibit the presence of a message body on either the request or the\n   response message.  Definitions of new methods can specify that only a\n   zero-length message body is allowed by requiring a Content-Length\n   header field with a value of \"0\".\n\n   A new method definition needs to indicate whether it is safe\n   (Section 4.2.1), idempotent (Section 4.2.2), cacheable\n   (Section 4.2.3), what semantics are to be associated with the payload\n   body if any is present in the request and what refinements the method\n   makes to header field or status code semantics.  If the new method is\n   cacheable, its definition ought to describe how, and under what\n   conditions, a cache can store a response and use it to satisfy a\n   subsequent request.  The new method ought to describe whether it can\n   be made conditional (Section 5.2) and, if so, how a server responds\n   when the condition is false.  Likewise, if the new method might have\n   some use for partial response semantics ([RFC7233]), it ought to\n   document this, too.\n\n      Note: Avoid defining a method name that starts with \"M-\", since\n      that prefix might be misinterpreted as having the semantics\n      assigned to it by [RFC2774].\n\n\n\nFielding & Reschke           Standards Track                   [Page 74]\n"}],"position":{"start":{"line":4442,"column":1,"offset":178167},"end":{"line":4499,"column":4,"offset":180498}}}],"position":{"start":{"line":4442,"column":1,"offset":178167},"end":{"line":4499,"column":4,"offset":180498}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4501,"column":1,"offset":180500},"end":{"line":4501,"column":4,"offset":180503}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n8.1.3.  Registrations\n\n   The \"Hypertext Transfer Protocol (HTTP) Method Registry\" has been\n   populated with the registrations below:\n\n   +---------+------+------------+---------------+\n   | Method  | Safe | Idempotent | Reference     |\n   +---------+------+------------+---------------+\n   | CONNECT | no   | no         | Section 4.3.6 |\n   | DELETE  | no   | yes        | Section 4.3.5 |\n   | GET     | yes  | yes        | Section 4.3.1 |\n   | HEAD    | yes  | yes        | Section 4.3.2 |\n   | OPTIONS | yes  | yes        | Section 4.3.7 |\n   | POST    | no   | no         | Section 4.3.3 |\n   | PUT     | no   | yes        | Section 4.3.4 |\n   | TRACE   | yes  | yes        | Section 4.3.8 |\n   +---------+------+------------+---------------+\n\n8.2.  Status Code Registry\n\n   The \"Hypertext Transfer Protocol (HTTP) Status Code Registry\" defines\n   the namespace for the response status-code token (Section 6).  The\n   status code registry is maintained at\n   <http://www.iana.org/assignments/http-status-codes>.\n\n   This section replaces the registration procedure for HTTP Status\n   Codes previously defined in SectionÂ 7.1 of [RFC2817].\n\n8.2.1.  Procedure\n\n   A registration MUST include the following fields:\n\n   o  Status Code (3 digits)\n\n   o  Short Description\n\n   o  Pointer to specification text\n\n   Values to be added to the HTTP status code namespace require IETF\n   Review (see [RFC5226], SectionÂ 4.1).\n\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 75]\n"}],"position":{"start":{"line":4503,"column":1,"offset":180505},"end":{"line":4560,"column":4,"offset":182090}}}],"position":{"start":{"line":4503,"column":1,"offset":180505},"end":{"line":4560,"column":4,"offset":182090}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4562,"column":1,"offset":182092},"end":{"line":4562,"column":4,"offset":182095}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n8.2.2.  Considerations for New Status Codes\n\n   When it is necessary to express semantics for a response that are not\n   defined by current status codes, a new status code can be registered.\n   Status codes are generic; they are potentially applicable to any\n   resource, not just one particular media type, kind of resource, or\n   application of HTTP.  As such, it is preferred that new status codes\n   be registered in a document that isn't specific to a single\n   application.\n\n   New status codes are required to fall under one of the categories\n   defined in Section 6.  To allow existing parsers to process the\n   response message, new status codes cannot disallow a payload,\n   although they can mandate a zero-length payload body.\n\n   Proposals for new status codes that are not yet widely deployed ought\n   to avoid allocating a specific number for the code until there is\n   clear consensus that it will be registered; instead, early drafts can\n   use a notation such as \"4NN\", or \"3N0\" .. \"3N9\", to indicate the\n   class of the proposed status code(s) without consuming a number\n   prematurely.\n\n   The definition of a new status code ought to explain the request\n   conditions that would cause a response containing that status code\n   (e.g., combinations of request header fields and/or method(s)) along\n   with any dependencies on response header fields (e.g., what fields\n   are required, what fields can modify the semantics, and what header\n   field semantics are further refined when used with the new status\n   code).\n\n   The definition of a new status code ought to specify whether or not\n   it is cacheable.  Note that all status codes can be cached if the\n   response they occur in has explicit freshness information; however,\n   status codes that are defined as being cacheable are allowed to be\n   cached without explicit freshness information.  Likewise, the\n   definition of a status code can place constraints upon cache\n   behavior.  See [RFC7234] for more information.\n\n   Finally, the definition of a new status code ought to indicate\n   whether the payload has any implied association with an identified\n   resource (Section 3.1.4.1).\n\n8.2.3.  Registrations\n\n   The status code registry has been updated with the registrations\n   below:\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 76]\n"}],"position":{"start":{"line":4564,"column":1,"offset":182097},"end":{"line":4621,"column":4,"offset":184526}}}],"position":{"start":{"line":4564,"column":1,"offset":182097},"end":{"line":4621,"column":4,"offset":184526}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4623,"column":1,"offset":184528},"end":{"line":4623,"column":4,"offset":184531}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   +-------+-------------------------------+----------------+\n   | Value | Description                   | Reference      |\n   +-------+-------------------------------+----------------+\n   | 100   | Continue                      | Section 6.2.1  |\n   | 101   | Switching Protocols           | Section 6.2.2  |\n   | 200   | OK                            | Section 6.3.1  |\n   | 201   | Created                       | Section 6.3.2  |\n   | 202   | Accepted                      | Section 6.3.3  |\n   | 203   | Non-Authoritative Information | Section 6.3.4  |\n   | 204   | No Content                    | Section 6.3.5  |\n   | 205   | Reset Content                 | Section 6.3.6  |\n   | 300   | Multiple Choices              | Section 6.4.1  |\n   | 301   | Moved Permanently             | Section 6.4.2  |\n   | 302   | Found                         | Section 6.4.3  |\n   | 303   | See Other                     | Section 6.4.4  |\n   | 305   | Use Proxy                     | Section 6.4.5  |\n   | 306   | (Unused)                      | Section 6.4.6  |\n   | 307   | Temporary Redirect            | Section 6.4.7  |\n   | 400   | Bad Request                   | Section 6.5.1  |\n   | 402   | Payment Required              | Section 6.5.2  |\n   | 403   | Forbidden                     | Section 6.5.3  |\n   | 404   | Not Found                     | Section 6.5.4  |\n   | 405   | Method Not Allowed            | Section 6.5.5  |\n   | 406   | Not Acceptable                | Section 6.5.6  |\n   | 408   | Request Timeout               | Section 6.5.7  |\n   | 409   | Conflict                      | Section 6.5.8  |\n   | 410   | Gone                          | Section 6.5.9  |\n   | 411   | Length Required               | Section 6.5.10 |\n   | 413   | Payload Too Large             | Section 6.5.11 |\n   | 414   | URI Too Long                  | Section 6.5.12 |\n   | 415   | Unsupported Media Type        | Section 6.5.13 |\n   | 417   | Expectation Failed            | Section 6.5.14 |\n   | 426   | Upgrade Required              | Section 6.5.15 |\n   | 500   | Internal Server Error         | Section 6.6.1  |\n   | 501   | Not Implemented               | Section 6.6.2  |\n   | 502   | Bad Gateway                   | Section 6.6.3  |\n   | 503   | Service Unavailable           | Section 6.6.4  |\n   | 504   | Gateway Timeout               | Section 6.6.5  |\n   | 505   | HTTP Version Not Supported    | Section 6.6.6  |\n   +-------+-------------------------------+----------------+\n\n8.3.  Header Field Registry\n\n   HTTP header fields are registered within the \"Message Headers\"\n   registry located at\n   <http://www.iana.org/assignments/message-headers>, as defined by\n   [BCP90].\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 77]\n"}],"position":{"start":{"line":4625,"column":1,"offset":184533},"end":{"line":4682,"column":4,"offset":187372}}}],"position":{"start":{"line":4625,"column":1,"offset":184533},"end":{"line":4682,"column":4,"offset":187372}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4684,"column":1,"offset":187374},"end":{"line":4684,"column":4,"offset":187377}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n8.3.1.  Considerations for New Header Fields\n\n   Header fields are key:value pairs that can be used to communicate\n   data about the message, its payload, the target resource, or the\n   connection (i.e., control data).  See SectionÂ 3.2 of [RFC7230] for a\n   general definition of header field syntax in HTTP messages.\n\n   The requirements for header field names are defined in [BCP90].\n\n   Authors of specifications defining new fields are advised to keep the\n   name as short as practical and not to prefix the name with \"X-\"\n   unless the header field will never be used on the Internet.  (The\n   \"X-\" prefix idiom has been extensively misused in practice; it was\n   intended to only be used as a mechanism for avoiding name collisions\n   inside proprietary software or intranet processing, since the prefix\n   would ensure that private names never collide with a newly registered\n   Internet name; see [BCP178] for further information).\n\n   New header field values typically have their syntax defined using\n   ABNF ([RFC5234]), using the extension defined in SectionÂ 7 of\n   [RFC7230] as necessary, and are usually constrained to the range of\n   US-ASCII characters.  Header fields needing a greater range of\n   characters can use an encoding such as the one defined in [RFC5987].\n\n   Leading and trailing whitespace in raw field values is removed upon\n   field parsing (SectionÂ 3.2.4 of [RFC7230]).  Field definitions where\n   leading or trailing whitespace in values is significant will have to\n   use a container syntax such as quoted-string (SectionÂ 3.2.6 of\n   [RFC7230]).\n\n   Because commas (\",\") are used as a generic delimiter between\n   field-values, they need to be treated with care if they are allowed\n   in the field-value.  Typically, components that might contain a comma\n   are protected with double-quotes using the quoted-string ABNF\n   production.\n\n   For example, a textual date and a URI (either of which might contain\n   a comma) could be safely carried in field-values like these:\n\n     Example-URI-Field: \"http://example.com/a.html,foo\",\n                        \"http://without-a-comma.example.com/\"\n     Example-Date-Field: \"Sat, 04 May 1996\", \"Wed, 14 Sep 2005\"\n\n   Note that double-quote delimiters almost always are used with the\n   quoted-string production; using a different syntax inside\n   double-quotes will likely cause unnecessary confusion.\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 78]\n"}],"position":{"start":{"line":4686,"column":1,"offset":187379},"end":{"line":4743,"column":4,"offset":189920}}}],"position":{"start":{"line":4686,"column":1,"offset":187379},"end":{"line":4743,"column":4,"offset":189920}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4745,"column":1,"offset":189922},"end":{"line":4745,"column":4,"offset":189925}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Many header fields use a format including (case-insensitively) named\n   parameters (for instance, Content-Type, defined in Section 3.1.1.5).\n   Allowing both unquoted (token) and quoted (quoted-string) syntax for\n   the parameter value enables recipients to use existing parser\n   components.  When allowing both forms, the meaning of a parameter\n   value ought to be independent of the syntax used for it (for an\n   example, see the notes on parameter handling for media types in\n   Section 3.1.1.1).\n\n   Authors of specifications defining new header fields are advised to\n   consider documenting:\n\n   o  Whether the field is a single value or whether it can be a list\n      (delimited by commas; see SectionÂ 3.2 of [RFC7230]).\n\n      If it does not use the list syntax, document how to treat messages\n      where the field occurs multiple times (a sensible default would be\n      to ignore the field, but this might not always be the right\n      choice).\n\n      Note that intermediaries and software libraries might combine\n      multiple header field instances into a single one, despite the\n      field's definition not allowing the list syntax.  A robust format\n      enables recipients to discover these situations (good example:\n      \"Content-Type\", as the comma can only appear inside quoted\n      strings; bad example: \"Location\", as a comma can occur inside a\n      URI).\n\n   o  Under what conditions the header field can be used; e.g., only in\n      responses or requests, in all messages, only on responses to a\n      particular request method, etc.\n\n   o  Whether the field should be stored by origin servers that\n      understand it upon a PUT request.\n\n   o  Whether the field semantics are further refined by the context,\n      such as by existing request methods or status codes.\n\n   o  Whether it is appropriate to list the field-name in the Connection\n      header field (i.e., if the header field is to be hop-by-hop; see\n      SectionÂ 6.1 of [RFC7230]).\n\n   o  Under what conditions intermediaries are allowed to insert,\n      delete, or modify the field's value.\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 79]\n"}],"position":{"start":{"line":4747,"column":1,"offset":189927},"end":{"line":4804,"column":4,"offset":192179}}}],"position":{"start":{"line":4747,"column":1,"offset":189927},"end":{"line":4804,"column":4,"offset":192179}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4806,"column":1,"offset":192181},"end":{"line":4806,"column":4,"offset":192184}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   o  Whether it is appropriate to list the field-name in a Vary\n      response header field (e.g., when the request header field is used\n      by an origin server's content selection algorithm; see\n      Section 7.1.4).\n\n   o  Whether the header field is useful or allowable in trailers (see\n      SectionÂ 4.1 of [RFC7230]).\n\n   o  Whether the header field ought to be preserved across redirects.\n\n   o  Whether it introduces any additional security considerations, such\n      as disclosure of privacy-related data.\n\n8.3.2.  Registrations\n\n   The \"Message Headers\" registry has been updated with the following\n   permanent registrations:\n\n   +-------------------+----------+----------+-----------------+\n   | Header Field Name | Protocol | Status   | Reference       |\n   +-------------------+----------+----------+-----------------+\n   | Accept            | http     | standard | Section 5.3.2   |\n   | Accept-Charset    | http     | standard | Section 5.3.3   |\n   | Accept-Encoding   | http     | standard | Section 5.3.4   |\n   | Accept-Language   | http     | standard | Section 5.3.5   |\n   | Allow             | http     | standard | Section 7.4.1   |\n   | Content-Encoding  | http     | standard | Section 3.1.2.2 |\n   | Content-Language  | http     | standard | Section 3.1.3.2 |\n   | Content-Location  | http     | standard | Section 3.1.4.2 |\n   | Content-Type      | http     | standard | Section 3.1.1.5 |\n   | Date              | http     | standard | Section 7.1.1.2 |\n   | Expect            | http     | standard | Section 5.1.1   |\n   | From              | http     | standard | Section 5.5.1   |\n   | Location          | http     | standard | Section 7.1.2   |\n   | Max-Forwards      | http     | standard | Section 5.1.2   |\n   | MIME-Version      | http     | standard | Appendix A.1    |\n   | Referer           | http     | standard | Section 5.5.2   |\n   | Retry-After       | http     | standard | Section 7.1.3   |\n   | Server            | http     | standard | Section 7.4.2   |\n   | User-Agent        | http     | standard | Section 5.5.3   |\n   | Vary              | http     | standard | Section 7.1.4   |\n   +-------------------+----------+----------+-----------------+\n\n   The change controller for the above registrations is: \"IETF\n   (iesg@ietf.org) - Internet Engineering Task Force\".\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 80]\n"}],"position":{"start":{"line":4808,"column":1,"offset":192186},"end":{"line":4865,"column":4,"offset":194667}}}],"position":{"start":{"line":4808,"column":1,"offset":192186},"end":{"line":4865,"column":4,"offset":194667}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4867,"column":1,"offset":194669},"end":{"line":4867,"column":4,"offset":194672}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n8.4.  Content Coding Registry\n\n   The \"HTTP Content Coding Registry\" defines the namespace for content\n   coding names (SectionÂ 4.2 of [RFC7230]).  The content coding registry\n   is maintained at <http://www.iana.org/assignments/http-parameters>.\n\n8.4.1.  Procedure\n\n   Content coding registrations MUST include the following fields:\n\n   o  Name\n\n   o  Description\n\n   o  Pointer to specification text\n\n   Names of content codings MUST NOT overlap with names of transfer\n   codings (SectionÂ 4 of [RFC7230]), unless the encoding transformation\n   is identical (as is the case for the compression codings defined in\n   SectionÂ 4.2 of [RFC7230]).\n\n   Values to be added to this namespace require IETF Review (see Section\n   4.1 of [RFC5226]) and MUST conform to the purpose of content coding\n   defined in this section.\n\n8.4.2.  Registrations\n\n   The \"HTTP Content Coding Registry\" has been updated with the\n   registrations below:\n\n   +----------+----------------------------------------+---------------+\n   | Name     | Description                            | Reference     |\n   +----------+----------------------------------------+---------------+\n   | identity | Reserved (synonym for \"no encoding\" in | Section 5.3.4 |\n   |          | Accept-Encoding)                       |               |\n   +----------+----------------------------------------+---------------+\n\n9.  Security Considerations\n\n   This section is meant to inform developers, information providers,\n   and users of known security concerns relevant to HTTP semantics and\n   its use for transferring information over the Internet.\n   Considerations related to message syntax, parsing, and routing are\n   discussed in SectionÂ 9 of [RFC7230].\n\n   The list of considerations below is not exhaustive.  Most security\n   concerns related to HTTP semantics are about securing server-side\n   applications (code behind the HTTP interface), securing user agent\n\n\n\nFielding & Reschke           Standards Track                   [Page 81]\n"}],"position":{"start":{"line":4869,"column":1,"offset":194674},"end":{"line":4926,"column":4,"offset":196751}}}],"position":{"start":{"line":4869,"column":1,"offset":194674},"end":{"line":4926,"column":4,"offset":196751}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4928,"column":1,"offset":196753},"end":{"line":4928,"column":4,"offset":196756}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   processing of payloads received via HTTP, or secure use of the\n   Internet in general, rather than security of the protocol.  Various\n   organizations maintain topical information and links to current\n   research on Web application security (e.g., [OWASP]).\n\n9.1.  Attacks Based on File and Path Names\n\n   Origin servers frequently make use of their local file system to\n   manage the mapping from effective request URI to resource\n   representations.  Most file systems are not designed to protect\n   against malicious file or path names.  Therefore, an origin server\n   needs to avoid accessing names that have a special significance to\n   the system when mapping the request target to files, folders, or\n   directories.\n\n   For example, UNIX, Microsoft Windows, and other operating systems use\n   \"..\" as a path component to indicate a directory level above the\n   current one, and they use specially named paths or file names to send\n   data to system devices.  Similar naming conventions might exist\n   within other types of storage systems.  Likewise, local storage\n   systems have an annoying tendency to prefer user-friendliness over\n   security when handling invalid or unexpected characters,\n   recomposition of decomposed characters, and case-normalization of\n   case-insensitive names.\n\n   Attacks based on such special names tend to focus on either denial-\n   of-service (e.g., telling the server to read from a COM port) or\n   disclosure of configuration and source files that are not meant to be\n   served.\n\n9.2.  Attacks Based on Command, Code, or Query Injection\n\n   Origin servers often use parameters within the URI as a means of\n   identifying system services, selecting database entries, or choosing\n   a data source.  However, data received in a request cannot be\n   trusted.  An attacker could construct any of the request data\n   elements (method, request-target, header fields, or body) to contain\n   data that might be misinterpreted as a command, code, or query when\n   passed through a command invocation, language interpreter, or\n   database interface.\n\n   For example, SQL injection is a common attack wherein additional\n   query language is inserted within some part of the request-target or\n   header fields (e.g., Host, Referer, etc.).  If the received data is\n   used directly within a SELECT statement, the query language might be\n   interpreted as a database command instead of a simple string value.\n   This type of implementation vulnerability is extremely common, in\n   spite of being easy to prevent.\n\n\n\nFielding & Reschke           Standards Track                   [Page 82]\n"}],"position":{"start":{"line":4930,"column":1,"offset":196758},"end":{"line":4987,"column":4,"offset":199461}}}],"position":{"start":{"line":4930,"column":1,"offset":196758},"end":{"line":4987,"column":4,"offset":199461}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":4989,"column":1,"offset":199463},"end":{"line":4989,"column":4,"offset":199466}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   In general, resource implementations ought to avoid use of request\n   data in contexts that are processed or interpreted as instructions.\n   Parameters ought to be compared to fixed strings and acted upon as a\n   result of that comparison, rather than passed through an interface\n   that is not prepared for untrusted data.  Received data that isn't\n   based on fixed parameters ought to be carefully filtered or encoded\n   to avoid being misinterpreted.\n\n   Similar considerations apply to request data when it is stored and\n   later processed, such as within log files, monitoring tools, or when\n   included within a data format that allows embedded scripts.\n\n9.3.  Disclosure of Personal Information\n\n   Clients are often privy to large amounts of personal information,\n   including both information provided by the user to interact with\n   resources (e.g., the user's name, location, mail address, passwords,\n   encryption keys, etc.) and information about the user's browsing\n   activity over time (e.g., history, bookmarks, etc.).  Implementations\n   need to prevent unintentional disclosure of personal information.\n\n9.4.  Disclosure of Sensitive Information in URIs\n\n   URIs are intended to be shared, not secured, even when they identify\n   secure resources.  URIs are often shown on displays, added to\n   templates when a page is printed, and stored in a variety of\n   unprotected bookmark lists.  It is therefore unwise to include\n   information within a URI that is sensitive, personally identifiable,\n   or a risk to disclose.\n\n   Authors of services ought to avoid GET-based forms for the submission\n   of sensitive data because that data will be placed in the\n   request-target.  Many existing servers, proxies, and user agents log\n   or display the request-target in places where it might be visible to\n   third parties.  Such services ought to use POST-based form submission\n   instead.\n\n   Since the Referer header field tells a target site about the context\n   that resulted in a request, it has the potential to reveal\n   information about the user's immediate browsing history and any\n   personal information that might be found in the referring resource's\n   URI.  Limitations on the Referer header field are described in\n   Section 5.5.2 to address some of its security considerations.\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 83]\n"}],"position":{"start":{"line":4991,"column":1,"offset":199468},"end":{"line":5048,"column":4,"offset":201944}}}],"position":{"start":{"line":4991,"column":1,"offset":199468},"end":{"line":5048,"column":4,"offset":201944}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":5050,"column":1,"offset":201946},"end":{"line":5050,"column":4,"offset":201949}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n9.5.  Disclosure of Fragment after Redirects\n\n   Although fragment identifiers used within URI references are not sent\n   in requests, implementers ought to be aware that they will be visible\n   to the user agent and any extensions or scripts running as a result\n   of the response.  In particular, when a redirect occurs and the\n   original request's fragment identifier is inherited by the new\n   reference in Location (Section 7.1.2), this might have the effect of\n   disclosing one site's fragment to another site.  If the first site\n   uses personal information in fragments, it ought to ensure that\n   redirects to other sites include a (possibly empty) fragment\n   component in order to block that inheritance.\n\n9.6.  Disclosure of Product Information\n\n   The User-Agent (Section 5.5.3), Via (SectionÂ 5.7.1 of [RFC7230]), and\n   Server (Section 7.4.2) header fields often reveal information about\n   the respective sender's software systems.  In theory, this can make\n   it easier for an attacker to exploit known security holes; in\n   practice, attackers tend to try all potential holes regardless of the\n   apparent software versions being used.\n\n   Proxies that serve as a portal through a network firewall ought to\n   take special precautions regarding the transfer of header information\n   that might identify hosts behind the firewall.  The Via header field\n   allows intermediaries to replace sensitive machine names with\n   pseudonyms.\n\n9.7.  Browser Fingerprinting\n\n   Browser fingerprinting is a set of techniques for identifying a\n   specific user agent over time through its unique set of\n   characteristics.  These characteristics might include information\n   related to its TCP behavior, feature capabilities, and scripting\n   environment, though of particular interest here is the set of unique\n   characteristics that might be communicated via HTTP.  Fingerprinting\n   is considered a privacy concern because it enables tracking of a user\n   agent's behavior over time without the corresponding controls that\n   the user might have over other forms of data collection (e.g.,\n   cookies).  Many general-purpose user agents (i.e., Web browsers) have\n   taken steps to reduce their fingerprints.\n\n   There are a number of request header fields that might reveal\n   information to servers that is sufficiently unique to enable\n   fingerprinting.  The From header field is the most obvious, though it\n   is expected that From will only be sent when self-identification is\n   desired by the user.  Likewise, Cookie header fields are deliberately\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 84]\n"}],"position":{"start":{"line":5052,"column":1,"offset":201951},"end":{"line":5109,"column":4,"offset":204674}}}],"position":{"start":{"line":5052,"column":1,"offset":201951},"end":{"line":5109,"column":4,"offset":204674}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":5111,"column":1,"offset":204676},"end":{"line":5111,"column":4,"offset":204679}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   designed to enable re-identification, so fingerprinting concerns only\n   apply to situations where cookies are disabled or restricted by the\n   user agent's configuration.\n\n   The User-Agent header field might contain enough information to\n   uniquely identify a specific device, usually when combined with other\n   characteristics, particularly if the user agent sends excessive\n   details about the user's system or extensions.  However, the source\n   of unique information that is least expected by users is proactive\n   negotiation (Section 5.3), including the Accept, Accept-Charset,\n   Accept-Encoding, and Accept-Language header fields.\n\n   In addition to the fingerprinting concern, detailed use of the\n   Accept-Language header field can reveal information the user might\n   consider to be of a private nature.  For example, understanding a\n   given language set might be strongly correlated to membership in a\n   particular ethnic group.  An approach that limits such loss of\n   privacy would be for a user agent to omit the sending of\n   Accept-Language except for sites that have been whitelisted, perhaps\n   via interaction after detecting a Vary header field that indicates\n   language negotiation might be useful.\n\n   In environments where proxies are used to enhance privacy, user\n   agents ought to be conservative in sending proactive negotiation\n   header fields.  General-purpose user agents that provide a high\n   degree of header field configurability ought to inform users about\n   the loss of privacy that might result if too much detail is provided.\n   As an extreme privacy measure, proxies could filter the proactive\n   negotiation header fields in relayed requests.\n\n10.  Acknowledgments\n\n   See SectionÂ 10 of [RFC7230].\n\n11.  References\n\n11.1.  Normative References\n\n   [RFC2045]  Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n              Extensions (MIME) Part One: Format of Internet Message\n              Bodies\", RFC 2045, November 1996.\n\n   [RFC2046]  Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n              Extensions (MIME) Part Two: Media Types\", RFC 2046,\n              November 1996.\n\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n\n\n\nFielding & Reschke           Standards Track                   [Page 85]\n"}],"position":{"start":{"line":5113,"column":1,"offset":204681},"end":{"line":5170,"column":4,"offset":207126}}}],"position":{"start":{"line":5113,"column":1,"offset":204681},"end":{"line":5170,"column":4,"offset":207126}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":5172,"column":1,"offset":207128},"end":{"line":5172,"column":4,"offset":207131}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, January 2005.\n\n   [RFC4647]  Phillips, A., Ed. and M. Davis, Ed., \"Matching of Language\n              Tags\", BCP 47, RFC 4647, September 2006.\n\n   [RFC5234]  Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n\n   [RFC5646]  Phillips, A., Ed. and M. Davis, Ed., \"Tags for Identifying\n              Languages\", BCP 47, RFC 5646, September 2009.\n\n   [RFC6365]  Hoffman, P. and J. Klensin, \"Terminology Used in\n              Internationalization in the IETF\", BCP 166, RFC 6365,\n              September 2011.\n\n   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC 7230, June 2014.\n\n   [RFC7232]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol (HTTP/1.1): Conditional Requests\", RFC 7232,\n              June 2014.\n\n   [RFC7233]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,\n              \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\",\n              RFC 7233, June 2014.\n\n   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n              Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\",\n              RFC 7234, June 2014.\n\n   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n              Protocol (HTTP/1.1): Authentication\", RFC 7235, June 2014.\n\n11.2.  Informative References\n\n   [BCP13]    Freed, N., Klensin, J., and T. Hansen, \"Media Type\n              Specifications and Registration Procedures\", BCP 13,\n              RFC 6838, January 2013.\n\n   [BCP178]   Saint-Andre, P., Crocker, D., and M. Nottingham,\n              \"Deprecating the \"X-\" Prefix and Similar Constructs in\n              Application Protocols\", BCP 178, RFC 6648, June 2012.\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 86]\n"}],"position":{"start":{"line":5174,"column":1,"offset":207133},"end":{"line":5231,"column":4,"offset":209282}}}],"position":{"start":{"line":5174,"column":1,"offset":207133},"end":{"line":5231,"column":4,"offset":209282}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":5233,"column":1,"offset":209284},"end":{"line":5233,"column":4,"offset":209287}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   [BCP90]    Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n              Procedures for Message Header Fields\", BCP 90, RFC 3864,\n              September 2004.\n\n   [OWASP]    van der Stock, A., Ed., \"A Guide to Building Secure Web\n              Applications and Web Services\", The Open Web Application\n              Security Project (OWASP) 2.0.1, July 2005,\n              <https://www.owasp.org/>.\n\n   [REST]     Fielding, R., \"Architectural Styles and the Design of\n              Network-based Software Architectures\",\n              Doctoral Dissertation, University of California, Irvine,\n              September 2000,\n              <http://roy.gbiv.com/pubs/dissertation/top.htm>.\n\n   [RFC1945]  Berners-Lee, T., Fielding, R., and H. Nielsen, \"Hypertext\n              Transfer Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n\n   [RFC2049]  Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n              Extensions (MIME) Part Five: Conformance Criteria and\n              Examples\", RFC 2049, November 1996.\n\n   [RFC2068]  Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T.\n              Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\",\n              RFC 2068, January 1997.\n\n   [RFC2295]  Holtman, K. and A. Mutz, \"Transparent Content Negotiation\n              in HTTP\", RFC 2295, March 1998.\n\n   [RFC2388]  Masinter, L., \"Returning Values from Forms:  multipart/\n              form-data\", RFC 2388, August 1998.\n\n   [RFC2557]  Palme, F., Hopmann, A., Shelness, N., and E. Stefferud,\n              \"MIME Encapsulation of Aggregate Documents, such as HTML\n              (MHTML)\", RFC 2557, March 1999.\n\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n\n   [RFC2774]  Frystyk, H., Leach, P., and S. Lawrence, \"An HTTP\n              Extension Framework\", RFC 2774, February 2000.\n\n   [RFC2817]  Khare, R. and S. Lawrence, \"Upgrading to TLS Within\n              HTTP/1.1\", RFC 2817, May 2000.\n\n   [RFC2978]  Freed, N. and J. Postel, \"IANA Charset Registration\n              Procedures\", BCP 19, RFC 2978, October 2000.\n\n\n\nFielding & Reschke           Standards Track                   [Page 87]\n"}],"position":{"start":{"line":5235,"column":1,"offset":209289},"end":{"line":5292,"column":4,"offset":211645}}}],"position":{"start":{"line":5235,"column":1,"offset":209289},"end":{"line":5292,"column":4,"offset":211645}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":5294,"column":1,"offset":211647},"end":{"line":5294,"column":4,"offset":211650}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n\n   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n\n   [RFC5322]  Resnick, P., \"Internet Message Format\", RFC 5322,\n              October 2008.\n\n   [RFC5789]  Dusseault, L. and J. Snell, \"PATCH Method for HTTP\",\n              RFC 5789, March 2010.\n\n   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n              \"Network Time Protocol Version 4: Protocol and Algorithms\n              Specification\", RFC 5905, June 2010.\n\n   [RFC5987]  Reschke, J., \"Character Set and Language Encoding for\n              Hypertext Transfer Protocol (HTTP) Header Field\n              Parameters\", RFC 5987, August 2010.\n\n   [RFC5988]  Nottingham, M., \"Web Linking\", RFC 5988, October 2010.\n\n   [RFC6265]  Barth, A., \"HTTP State Management Mechanism\", RFC 6265,\n              April 2011.\n\n   [RFC6266]  Reschke, J., \"Use of the Content-Disposition Header Field\n              in the Hypertext Transfer Protocol (HTTP)\", RFC 6266,\n              June 2011.\n\n   [RFC7238]  Reschke, J., \"The Hypertext Transfer Protocol (HTTP)\n              Status Code 308 (Permanent Redirect)\", RFC 7238,\n              June 2014.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 88]\n"}],"position":{"start":{"line":5296,"column":1,"offset":211652},"end":{"line":5353,"column":4,"offset":213190}}}],"position":{"start":{"line":5296,"column":1,"offset":211652},"end":{"line":5353,"column":4,"offset":213190}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":5355,"column":1,"offset":213192},"end":{"line":5355,"column":4,"offset":213195}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\nAppendix A.  Differences between HTTP and MIME\n\n   HTTP/1.1 uses many of the constructs defined for the Internet Message\n   Format [RFC5322] and the Multipurpose Internet Mail Extensions (MIME)\n   [RFC2045] to allow a message body to be transmitted in an open\n   variety of representations and with extensible header fields.\n   However, RFC 2045 is focused only on email; applications of HTTP have\n   many characteristics that differ from email; hence, HTTP has features\n   that differ from MIME.  These differences were carefully chosen to\n   optimize performance over binary connections, to allow greater\n   freedom in the use of new media types, to make date comparisons\n   easier, and to acknowledge the practice of some early HTTP servers\n   and clients.\n\n   This appendix describes specific areas where HTTP differs from MIME.\n   Proxies and gateways to and from strict MIME environments need to be\n   aware of these differences and provide the appropriate conversions\n   where necessary.\n\nA.1.  MIME-Version\n\n   HTTP is not a MIME-compliant protocol.  However, messages can include\n   a single MIME-Version header field to indicate what version of the\n   MIME protocol was used to construct the message.  Use of the\n   MIME-Version header field indicates that the message is in full\n   conformance with the MIME protocol (as defined in [RFC2045]).\n   Senders are responsible for ensuring full conformance (where\n   possible) when exporting HTTP messages to strict MIME environments.\n\nA.2.  Conversion to Canonical Form\n\n   MIME requires that an Internet mail body part be converted to\n   canonical form prior to being transferred, as described in SectionÂ 4\n   of [RFC2049].  Section 3.1.1.3 of this document describes the forms\n   allowed for subtypes of the \"text\" media type when transmitted over\n   HTTP.  [RFC2046] requires that content with a type of \"text\"\n   represent line breaks as CRLF and forbids the use of CR or LF outside\n   of line break sequences.  HTTP allows CRLF, bare CR, and bare LF to\n   indicate a line break within text content.\n\n   A proxy or gateway from HTTP to a strict MIME environment ought to\n   translate all line breaks within the text media types described in\n   Section 3.1.1.3 of this document to the RFC 2049 canonical form of\n   CRLF.  Note, however, this might be complicated by the presence of a\n   Content-Encoding and by the fact that HTTP allows the use of some\n   charsets that do not use octets 13 and 10 to represent CR and LF,\n   respectively.\n\n\n\n\nFielding & Reschke           Standards Track                   [Page 89]\n"}],"position":{"start":{"line":5357,"column":1,"offset":213197},"end":{"line":5414,"column":4,"offset":215855}}}],"position":{"start":{"line":5357,"column":1,"offset":213197},"end":{"line":5414,"column":4,"offset":215855}}},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[],"position":{"start":{"line":5416,"column":1,"offset":215857},"end":{"line":5416,"column":4,"offset":215860}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"RFC 7231             HTTP/1.1 Semantics and Content            June 2014\n\n\n   Conversion will break any cryptographic checksums applied to the\n   original content unless the original content is already in canonical\n   form.  Therefore, the canonical form is recommended for any content\n   that uses such checksums in HTTP.\n\nA.3.  Conversion of Date Formats\n\n   HTTP/1.1 uses a restricted set of date formats (Section 7.1.1.1) to\n   simplify the process of date comparison.  Proxies and gateways from\n   other protocols ought to ensure that any Date header field present in\n   a message conforms to one of the HTTP/1.1 formats and rewrite the\n   date if necessary.\n\nA.4.  Conversion of Content-Encoding\n\n   MIME does not include any concept equivalent to HTTP/1.1's\n   Content-Encoding header field.  Since this acts as a modifier on the\n   media type, proxies and gateways from HTTP to MIME-compliant\n   protocols ought to either change the value of the Content-Type header\n   field or decode the representation before forwarding the message.\n   (Some experimental applications of Content-Type for Internet mail\n   have used a media-type parameter of \";conversions=<content-coding>\"\n   to perform a function equivalent to Content-Encoding.  However, this\n   parameter is not part of the MIME standards).\n\nA.5.  Conversion of Content-Transfer-Encoding\n\n   HTTP does not use the Content-Transfer-Encoding field of MIME.\n   Proxies and gateways from MIME-compliant protocols to HTTP need to\n   remove any Content-Transfer-Encoding prior to delivering the response\n   message to an HTTP client.\n\n   Proxies and gateways from HTTP to MIME-compliant protocols are\n   responsible for ensuring that the message is in the correct format\n   and encoding for safe transport on that protocol, where \"safe\n   transport\" is defined by the limitations of the protocol being used.\n   Such a proxy or gateway ought to transform and label the data with an\n   appropriate Content-Transfer-Encoding if doing so will improve the\n   likelihood of safe transport over the destination protocol.\n\nA.6.  MHTML and Line Length Limitations\n\n   HTTP implementations that share code with MHTML [RFC2557]\n   implementations need to be aware of MIME line length limitations.\n   Since HTTP does not have this limitation, HTTP does not fold long\n   lines.  MHTML messages being transported by HTTP follow all\n   conventions of MHTML, including line length limitations and folding,\n   canonicalization, etc., since HTTP transfers message-bodies as\n"}],"position":{"start":{"line":5418,"column":1,"offset":215862},"end":{"line":5471,"column":4,"offset":218383}}}],"position":{"start":{"line":5418,"column":1,"offset":215862},"end":{"line":5471,"column":4,"offset":218383}}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":5471,"column":4,"offset":218383}}}}